netcdf sgp30ecorE1.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (4 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor1:/data/collection/sgp/sgpecorE1.00/2004_0615_0000_01.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "1" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  Data for winds from 90 to 270 degrees\n",
    "are usually representative for flows over wheat.  The crop height, density,\n",
    "and condition varies seasonally.  A description of the crop condition can\n",
    "be found in the SURFCOND weekly reports.  There is a north-south road\n",
    "approximately 200 m to the east that could disturb the wind flows." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "1" ;
		:IRGA_serial_number = "75H-0463" ;
		:sonic_serial_number = "P000065" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.220000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE1.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,1:09:07, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE1.b1.20040615.020000 {
dimensions:
	time = UNLIMITED ; // (2 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,2:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 02:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor1:/data/collection/sgp/sgpecorE1.00/2004_0615_0200_01.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "1" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  Data for winds from 90 to 270 degrees\n",
    "are usually representative for flows over wheat.  The crop height, density,\n",
    "and condition varies seasonally.  A description of the crop condition can\n",
    "be found in the SURFCOND weekly reports.  There is a north-south road\n",
    "approximately 200 m to the east that could disturb the wind flows." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "1" ;
		:IRGA_serial_number = "none" ;
		:sonic_serial_number = "P000065" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.220000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE1.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,3:09:33, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE1.b1.20040615.030000 {
dimensions:
	time = UNLIMITED ; // (13 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,3:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 03:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor1:/data/collection/sgp/sgpecorE1.00/2004_0615_0300_01.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "1" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  Data for winds from 90 to 270 degrees\n",
    "are usually representative for flows over wheat.  The crop height, density,\n",
    "and condition varies seasonally.  A description of the crop condition can\n",
    "be found in the SURFCOND weekly reports.  There is a north-south road\n",
    "approximately 200 m to the east that could disturb the wind flows." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "1" ;
		:IRGA_serial_number = "75H-0463" ;
		:sonic_serial_number = "P000065" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.220000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE1.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,4:08:24, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE10.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor10:/data/collection/sgp/sgpecorE10.00/2004_0615_0000_10.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "10" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed south of a mowed grass\n",
    "drainage ditch.  The ditch heads southwest just west of the tower.  There\n",
    "is a crop of alfalfa south of the drainage ditch.  The crop height, density,\n",
    "and condition varies seasonally.  A description of the crop condition can\n",
    "be found in the SURFCOND weekly reports.  A north-south road approximately\n",
    "180 m to the east and an east-west road approximately 300 m to the south\n",
    "could disturb wind flowing from those directions.  Data for winds from 90\n",
    "to 220 deg are usually representative for flows over alfalfa." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "10" ;
		:IRGA_serial_number = "75H-0471" ;
		:sonic_serial_number = "P000063" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.230000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE10.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,1:13:09, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE14.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor14:/data/collection/sgp/sgpecorE14.00/2004_0615_0000_14.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "14" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  The crop height, density, and condition\n",
    "varies seasonally.  A description of the crop condition can be found in the\n",
    "SURFCOND weekly reports.  The fence heads north a short distance to the west.\n",
    "Data for winds from 90 to 270 degrees are usually representative for flows\n",
    "over wheat." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "14" ;
		:IRGA_serial_number = "75H-0472" ;
		:sonic_serial_number = "P000060" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.340000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE14.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,1:16:13, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE16.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor16:/data/collection/sgp/sgpecorE16.00/2004_0615_0000_16.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "16" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  The crop height, density, and condition\n",
    "varies seasonally.  A description of the crop condition can be found in the\n",
    "SURFCOND weekly reports.  More pasture begins approximately 230 m to the west.\n",
    "There is a road approximately 170 m to the east that could disturb the wind\n",
    "flows.  Data for winds from 90 to 270 degrees are usually representative for\n",
    "flows over wheat." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "16" ;
		:IRGA_serial_number = "75H-0465" ;
		:sonic_serial_number = "P000061" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.230000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE16.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,6:16:58, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE21.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor21:/data/collection/sgp/sgpecorE21.00/2004_0615_0000_21.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "21" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  The fence heads north a short distance to\n",
    "the west.  Data for winds from 90 to 270 degrees are usually representative\n",
    "for flows over wheat.  The crop height, density, and condition varies\n",
    "seasonally.  A description of the crop condition can be found in the SURFCOND\n",
    "weekly reports.  There are buildings approximately  250 - 300 m to the south\n",
    "and south-south-west that could disturb the wind flows." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "21" ;
		:IRGA_serial_number = "75H-0468" ;
		:sonic_serial_number = "P000064" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.200000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE21.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,2:17:40, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE24.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor24:/data/collection/sgp/sgpecorE24.00/2004_0615_0000_24.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "24" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates native grass from wheat.  The crop height, density, and\n",
    "condition varies seasonally.  A description of the crop condition can be\n",
    "found in the SURFCOND weekly reports.  Data for winds from 90 to 270 degrees\n",
    "are usually representative for flows over wheat." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "24" ;
		:IRGA_serial_number = "75H-0469" ;
		:sonic_serial_number = "P000066" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.260000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE24.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,1:21:44, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE5.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor5:/data/collection/sgp/sgpecorE5.00/2004_0615_0000_05.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "5" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from Milo. Data for winds from 90 to 270 degrees\n",
    "are usually representative for flows over Milo in spring and summer, and\n",
    "for flows over Milo tillage during the remainder of the year.  The crop\n",
    "height, density, and condition varies seasonally.  A description of the \n",
    "crop condition can be found in the SURFCOND weekly reports.  There is a\n",
    "short tree row running east and west located approximately 75-100m to the\n",
    "north, and a broken tree row running north and south located approximately\n",
    "200-300m to the west that could distrub the wind flow." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "5" ;
		:IRGA_serial_number = "75H-0462" ;
		:sonic_serial_number = "P000059" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.140000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE5.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,1:10:41, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
netcdf sgp30ecorE6.b1.20040615.000000 {
dimensions:
	time = UNLIMITED ; // (48 currently)
variables:
	int base_time ;
		base_time:string = "15-Jun-2004,0:00:00 GMT" ;
		base_time:long_name = "Base time in Epoch" ;
		base_time:units = "seconds since 1970-1-1 0:00:00 0:00" ;
	double time_offset(time) ;
		time_offset:long_name = "Time offset from base_time" ;
		time_offset:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	double time(time) ;
		time:long_name = "Time offset from midnight" ;
		time:units = "seconds since 2004-06-15 00:00:00 0:00" ;
	int qc_time(time) ;
		qc_time:long_name = "Results of quality checks on sample time" ;
		qc_time:units = "unitless" ;
		qc_time:description = "The qc_time values are calculated by comparing each sample\n",
    "time with the previous time (i.e. delta_t = t[n] - t[n-1]).\n",
    "If the \'qc_check_prior\' flag is set the first sample time\n",
    "from a new raw file will be compared against the time just\n",
    "previous to it in the stored data. If the \'qc_check_prior\'\n",
    "flag is not set the qc_time value for the first sample time\n",
    "will be set to 0\n",
    "\n",
    "The qc_time bit values are as follows:\n",
    "=========================================================\n",
    "0x0 = delta time is within the specified range\n",
    "0x1 = delta time is equal to 0, duplicate sample times\n",
    "0x2 = delta time is less than the \'delta_t_lower_limit\'\n",
    "0x4 = delta time is greater than the \'delta_t_upper_limit\'\n",
    "\n",
    "" ;
		qc_time:delta_t_lower_limit = 1260 ;
		qc_time:delta_t_upper_limit = 2340 ;
		qc_time:prior_sample_flag = 1 ;
	float mean_u(time) ;
		mean_u:long_name = "mean u wind component" ;
		mean_u:units = "m/s" ;
		mean_u:valid_min = -30.f ;
		mean_u:valid_max = 30.f ;
		mean_u:resolution = 0.01f ;
		mean_u:missing_value = -9999.f ;
	int qc_mean_u(time) ;
		qc_mean_u:long_name = "Quality check results on field: mean u wind component" ;
		qc_mean_u:units = "unitless" ;
	float mean_v(time) ;
		mean_v:long_name = "mean v wind component" ;
		mean_v:units = "m/s" ;
		mean_v:valid_min = -30.f ;
		mean_v:valid_max = 30.f ;
		mean_v:resolution = 0.01f ;
		mean_v:missing_value = -9999.f ;
	int qc_mean_v(time) ;
		qc_mean_v:long_name = "Quality check results on field: mean v wind component" ;
		qc_mean_v:units = "unitless" ;
	float mean_w(time) ;
		mean_w:long_name = "mean w (vertical) wind component" ;
		mean_w:units = "m/s" ;
		mean_w:valid_min = -30.f ;
		mean_w:valid_max = 30.f ;
		mean_w:resolution = 0.01f ;
		mean_w:missing_value = -9999.f ;
	int qc_mean_w(time) ;
		qc_mean_w:long_name = "Quality check results on field: mean w (vertical) wind component" ;
		qc_mean_w:units = "unitless" ;
	float mean_t(time) ;
		mean_t:long_name = "mean t temperature (sonic anemometer)" ;
		mean_t:units = "K" ;
		mean_t:valid_min = 234.f ;
		mean_t:valid_max = 335.f ;
		mean_t:resolution = 0.1f ;
		mean_t:missing_value = -9999.f ;
	int qc_mean_t(time) ;
		qc_mean_t:long_name = "Quality check results on field: mean t temperature (sonic anemometer)" ;
		qc_mean_t:units = "unitless" ;
	float mean_q(time) ;
		mean_q:long_name = "mean water vapor density" ;
		mean_q:units = "mmol/m^3" ;
		mean_q:resolution = 0.1f ;
		mean_q:missing_value = -9999.f ;
		mean_q:valid_min = 0.f ;
		mean_q:valid_max = 2000.f ;
	int qc_mean_q(time) ;
		qc_mean_q:long_name = "Quality check results on field: mean water vapor density" ;
		qc_mean_q:units = "unitless" ;
	float mean_c(time) ;
		mean_c:long_name = "mean CO2 density" ;
		mean_c:units = "mmol/m^3" ;
		mean_c:resolution = 0.01f ;
		mean_c:missing_value = -9999.f ;
		mean_c:valid_min = 8.f ;
		mean_c:valid_max = 32.f ;
	int qc_mean_c(time) ;
		qc_mean_c:long_name = "Quality check results on field: mean CO2 density" ;
		qc_mean_c:units = "unitless" ;
	float var_u(time) ;
		var_u:long_name = "variance of variable u" ;
		var_u:units = "(m/s)^2" ;
		var_u:valid_min = 0.001f ;
		var_u:valid_max = 5.f ;
		var_u:resolution = 0.001f ;
		var_u:missing_value = -9999.f ;
	int qc_var_u(time) ;
		qc_var_u:long_name = "Quality check results on field: variance of variable u" ;
		qc_var_u:units = "unitless" ;
	float var_v(time) ;
		var_v:long_name = "variance of variable v" ;
		var_v:units = "(m/s)^2" ;
		var_v:valid_min = 0.001f ;
		var_v:valid_max = 5.f ;
		var_v:resolution = 0.001f ;
		var_v:missing_value = -9999.f ;
	int qc_var_v(time) ;
		qc_var_v:long_name = "Quality check results on field: variance of variable v" ;
		qc_var_v:units = "unitless" ;
	float var_w(time) ;
		var_w:long_name = "variance of variable w" ;
		var_w:units = "(m/s)^2" ;
		var_w:valid_min = 0.001f ;
		var_w:valid_max = 3.f ;
		var_w:resolution = 0.001f ;
		var_w:missing_value = -9999.f ;
	int qc_var_w(time) ;
		qc_var_w:long_name = "Quality check results on field: variance of variable w" ;
		qc_var_w:units = "unitless" ;
	float var_t(time) ;
		var_t:long_name = "variance of variable t" ;
		var_t:units = "K^2" ;
		var_t:valid_min = 0.001f ;
		var_t:valid_max = 5.f ;
		var_t:resolution = 0.001f ;
		var_t:missing_value = -9999.f ;
	int qc_var_t(time) ;
		qc_var_t:long_name = "Quality check results on field: variance of variable t" ;
		qc_var_t:units = "unitless" ;
	float var_q(time) ;
		var_q:long_name = "variance of variable q" ;
		var_q:units = "(mmol/m^3)^2" ;
		var_q:valid_min = 100.f ;
		var_q:valid_max = 150000.f ;
		var_q:resolution = 100.f ;
		var_q:missing_value = -9999.f ;
	int qc_var_q(time) ;
		qc_var_q:long_name = "Quality check results on field: variance of variable q" ;
		qc_var_q:units = "unitless" ;
	float var_c(time) ;
		var_c:long_name = "variance of variable c" ;
		var_c:units = "(mmol/m^3)^2" ;
		var_c:valid_min = 0.001f ;
		var_c:valid_max = 4.f ;
		var_c:resolution = 0.001f ;
		var_c:missing_value = -9999.f ;
	int qc_var_c(time) ;
		qc_var_c:long_name = "Quality check results on field: variance of variable c" ;
		qc_var_c:units = "unitless" ;
	float skew_u(time) ;
		skew_u:long_name = "skewness of variable u" ;
		skew_u:units = "unitless" ;
		skew_u:missing_value = -9999.f ;
	float skew_v(time) ;
		skew_v:long_name = "skewness of variable v" ;
		skew_v:units = "unitless" ;
		skew_v:missing_value = -9999.f ;
	float skew_w(time) ;
		skew_w:long_name = "skewness of variable w" ;
		skew_w:units = "unitless" ;
		skew_w:missing_value = -9999.f ;
	float skew_t(time) ;
		skew_t:long_name = "skewness of variable t" ;
		skew_t:units = "unitless" ;
		skew_t:missing_value = -9999.f ;
	float skew_q(time) ;
		skew_q:long_name = "skewness of variable q" ;
		skew_q:units = "unitless" ;
		skew_q:missing_value = -9999.f ;
	float skew_c(time) ;
		skew_c:long_name = "skewness of variable c" ;
		skew_c:units = "unitless" ;
		skew_c:missing_value = -9999.f ;
	float kurt_u(time) ;
		kurt_u:long_name = "kurtosis of variable u" ;
		kurt_u:units = "unitless" ;
		kurt_u:missing_value = -9999.f ;
	float kurt_v(time) ;
		kurt_v:long_name = "kurtosis of variable v" ;
		kurt_v:units = "unitless" ;
		kurt_v:missing_value = -9999.f ;
	float kurt_w(time) ;
		kurt_w:long_name = "kurtosis of variable w" ;
		kurt_w:units = "unitless" ;
		kurt_w:missing_value = -9999.f ;
	float kurt_t(time) ;
		kurt_t:long_name = "kurtosis of variable t" ;
		kurt_t:units = "unitless" ;
		kurt_t:missing_value = -9999.f ;
	float kurt_q(time) ;
		kurt_q:long_name = "kurtosis of variable q" ;
		kurt_q:units = "unitless" ;
		kurt_q:missing_value = -9999.f ;
	float kurt_c(time) ;
		kurt_c:long_name = "kurtosis of variable c" ;
		kurt_c:units = "unitless" ;
		kurt_c:missing_value = -9999.f ;
	float cvar_uv(time) ;
		cvar_uv:long_name = "covariance uv" ;
		cvar_uv:units = "(m/s)^2" ;
		cvar_uv:missing_value = -9999.f ;
	float cvar_uw(time) ;
		cvar_uw:long_name = "covariance uw" ;
		cvar_uw:units = "(m/s)^2" ;
		cvar_uw:missing_value = -9999.f ;
	float cvar_ut(time) ;
		cvar_ut:long_name = "covariance ut" ;
		cvar_ut:units = "K m/s" ;
		cvar_ut:missing_value = -9999.f ;
	float cvar_uq(time) ;
		cvar_uq:long_name = "covariance uq" ;
		cvar_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_uq:missing_value = -9999.f ;
	float cvar_uc(time) ;
		cvar_uc:long_name = "covariance uc" ;
		cvar_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_uc:missing_value = -9999.f ;
	float cvar_vw(time) ;
		cvar_vw:long_name = "covariance vw" ;
		cvar_vw:units = "(m/s)^2" ;
		cvar_vw:missing_value = -9999.f ;
	float cvar_vt(time) ;
		cvar_vt:long_name = "covariance vt" ;
		cvar_vt:units = "K m/s" ;
		cvar_vt:missing_value = -9999.f ;
	float cvar_vq(time) ;
		cvar_vq:long_name = "covariance vq" ;
		cvar_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_vq:missing_value = -9999.f ;
	float cvar_vc(time) ;
		cvar_vc:long_name = "covariance vc" ;
		cvar_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_vc:missing_value = -9999.f ;
	float cvar_wt(time) ;
		cvar_wt:long_name = "covariance wt" ;
		cvar_wt:units = "K m/s" ;
		cvar_wt:missing_value = -9999.f ;
	float cvar_wq(time) ;
		cvar_wq:long_name = "covariance wq" ;
		cvar_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_wq:missing_value = -9999.f ;
	float cvar_wc(time) ;
		cvar_wc:long_name = "covariance wc" ;
		cvar_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_wc:missing_value = -9999.f ;
	float cvar_tq(time) ;
		cvar_tq:long_name = "covariance tq" ;
		cvar_tq:units = "K mmol/m^3" ;
		cvar_tq:missing_value = -9999.f ;
	float cvar_tc(time) ;
		cvar_tc:long_name = "covariance tc" ;
		cvar_tc:units = "K mmol/m^3" ;
		cvar_tc:missing_value = -9999.f ;
	float cvar_qc(time) ;
		cvar_qc:long_name = "covariance qc" ;
		cvar_qc:units = "(mmol/m^3)^2" ;
		cvar_qc:missing_value = -9999.f ;
	float elev(time) ;
		elev:long_name = "vertical (elevation) wind angle" ;
		elev:units = "deg" ;
		elev:valid_min = -7.f ;
		elev:valid_max = 7.f ;
		elev:resolution = 0.001f ;
		elev:missing_value = -9999.f ;
	int qc_elev(time) ;
		qc_elev:long_name = "Quality check results on field: vertical (elevation) wind angle" ;
		qc_elev:units = "unitless" ;
	float phi(time) ;
		phi:long_name = "rotation to <v>=0" ;
		phi:units = "deg" ;
		phi:missing_value = -9999.f ;
	float mean_rot_u(time) ;
		mean_rot_u:long_name = "rotated mean u" ;
		mean_rot_u:units = "m/s" ;
		mean_rot_u:missing_value = -9999.f ;
	float mean_rot_v(time) ;
		mean_rot_v:long_name = "rotated mean v" ;
		mean_rot_v:units = "m/s" ;
		mean_rot_v:missing_value = -9999.f ;
	float mean_rot_w(time) ;
		mean_rot_w:long_name = "rotated mean w" ;
		mean_rot_w:units = "m/s" ;
		mean_rot_w:missing_value = -9999.f ;
	float var_rot_u(time) ;
		var_rot_u:long_name = "rotated variance u" ;
		var_rot_u:units = "(m/s)^2" ;
		var_rot_u:missing_value = -9999.f ;
	float var_rot_v(time) ;
		var_rot_v:long_name = "rotated variance v" ;
		var_rot_v:units = "(m/s)^2" ;
		var_rot_v:missing_value = -9999.f ;
	float var_rot_w(time) ;
		var_rot_w:long_name = "rotated variance w" ;
		var_rot_w:units = "(m/s)^2" ;
		var_rot_w:missing_value = -9999.f ;
	float cvar_rot_uv(time) ;
		cvar_rot_uv:long_name = "rotated covariance uv" ;
		cvar_rot_uv:units = "(m/s)^2" ;
		cvar_rot_uv:missing_value = -9999.f ;
	float cvar_rot_uw(time) ;
		cvar_rot_uw:long_name = "rotated covariance uw" ;
		cvar_rot_uw:units = "(m/s)^2" ;
		cvar_rot_uw:missing_value = -9999.f ;
	float cvar_rot_ut(time) ;
		cvar_rot_ut:long_name = "rotated covariance ut" ;
		cvar_rot_ut:units = "K m/s" ;
		cvar_rot_ut:missing_value = -9999.f ;
	float cvar_rot_uq(time) ;
		cvar_rot_uq:long_name = "rotated covariance uq" ;
		cvar_rot_uq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uq:missing_value = -9999.f ;
	float cvar_rot_uc(time) ;
		cvar_rot_uc:long_name = "rotated covariance uc" ;
		cvar_rot_uc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_uc:missing_value = -9999.f ;
	float cvar_rot_vw(time) ;
		cvar_rot_vw:long_name = "rotated covariance vw" ;
		cvar_rot_vw:units = "(m/s)^2" ;
		cvar_rot_vw:missing_value = -9999.f ;
	float cvar_rot_vt(time) ;
		cvar_rot_vt:long_name = "rotated covariance vt" ;
		cvar_rot_vt:units = "K m/s" ;
		cvar_rot_vt:missing_value = -9999.f ;
	float cvar_rot_vq(time) ;
		cvar_rot_vq:long_name = "rotated covariance vq" ;
		cvar_rot_vq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vq:missing_value = -9999.f ;
	float cvar_rot_vc(time) ;
		cvar_rot_vc:long_name = "rotated covariance vc" ;
		cvar_rot_vc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_vc:missing_value = -9999.f ;
	float cvar_rot_wt(time) ;
		cvar_rot_wt:long_name = "rotated covariance wt" ;
		cvar_rot_wt:units = "K m/s" ;
		cvar_rot_wt:missing_value = -9999.f ;
	float cvar_rot_wq(time) ;
		cvar_rot_wq:long_name = "rotated covariance wq" ;
		cvar_rot_wq:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wq:missing_value = -9999.f ;
	float cvar_rot_wc(time) ;
		cvar_rot_wc:long_name = "rotated covariance wc" ;
		cvar_rot_wc:units = "(m/s)(mmol/m^3)" ;
		cvar_rot_wc:missing_value = -9999.f ;
	float wind_spd(time) ;
		wind_spd:long_name = "vector averaged wind speed" ;
		wind_spd:units = "m/s" ;
		wind_spd:valid_min = 0.f ;
		wind_spd:valid_max = 42.f ;
		wind_spd:resolution = 0.01f ;
		wind_spd:missing_value = -9999.f ;
	int qc_wind_spd(time) ;
		qc_wind_spd:long_name = "Quality check results on field: vector averaged wind speed" ;
		qc_wind_spd:units = "unitless" ;
	float wind_dir(time) ;
		wind_dir:long_name = "vector averaged wind direction" ;
		wind_dir:units = "deg" ;
		wind_dir:valid_min = 0.f ;
		wind_dir:valid_max = 360.f ;
		wind_dir:resolution = 1.f ;
		wind_dir:missing_value = -9999.f ;
	int qc_wind_dir(time) ;
		qc_wind_dir:long_name = "Quality check results on field: vector averaged wind direction" ;
		qc_wind_dir:units = "unitless" ;
	float std_wind_dir(time) ;
		std_wind_dir:long_name = "standard deviation of wind direction" ;
		std_wind_dir:units = "deg" ;
		std_wind_dir:valid_min = 0.f ;
		std_wind_dir:resolution = 0.1f ;
		std_wind_dir:missing_value = -9999.f ;
	int qc_std_wind_dir(time) ;
		qc_std_wind_dir:long_name = "Quality check results on field: standard deviation of wind direction" ;
		qc_std_wind_dir:units = "unitless" ;
	float std_elev(time) ;
		std_elev:long_name = "standard deviation of wind elevation angle" ;
		std_elev:units = "deg" ;
		std_elev:valid_min = 0.f ;
		std_elev:resolution = 0.1f ;
		std_elev:missing_value = -9999.f ;
	int qc_std_elev(time) ;
		qc_std_elev:long_name = "Quality check results on field: standard deviation of wind elevation angle" ;
		qc_std_elev:units = "unitless" ;
	float atm_pres(time) ;
		atm_pres:long_name = "average atmospheric pressure (IGRA internal sensor)" ;
		atm_pres:units = "kPa" ;
		atm_pres:valid_min = 80.f ;
		atm_pres:valid_max = 110.f ;
		atm_pres:resolution = 0.1f ;
		atm_pres:missing_value = -9999.f ;
	int qc_atm_pres(time) ;
		qc_atm_pres:long_name = "Quality check results on field: average atmospheric pressure (IGRA internal sensor)" ;
		qc_atm_pres:units = "unitless" ;
	float temp_irga(time) ;
		temp_irga:long_name = "average temperature (IGRA internal sensor)" ;
		temp_irga:units = "C" ;
		temp_irga:valid_min = -30.f ;
		temp_irga:valid_max = 60.f ;
		temp_irga:resolution = 0.1f ;
		temp_irga:missing_value = -9999.f ;
	int qc_temp_irga(time) ;
		qc_temp_irga:long_name = "Quality check results on field: average temperature (IGRA internal sensor)" ;
		qc_temp_irga:units = "unitless" ;
	float cp(time) ;
		cp:long_name = "specific heat of moist air" ;
		cp:units = "J/(kg K)" ;
		cp:valid_min = 1006.f ;
		cp:valid_max = 1122.f ;
		cp:resolution = 1.f ;
		cp:missing_value = -9999.f ;
	int qc_cp(time) ;
		qc_cp:long_name = "Quality check results on field: specific heat of moist air" ;
		qc_cp:units = "unitless" ;
	float rho(time) ;
		rho:long_name = "moist air density" ;
		rho:units = "kg/m^3" ;
		rho:valid_min = 1.1f ;
		rho:valid_max = 1.35f ;
		rho:resolution = 0.01f ;
		rho:missing_value = -9999.f ;
	int qc_rho(time) ;
		qc_rho:long_name = "Quality check results on field: moist air density" ;
		qc_rho:units = "unitless" ;
	float lv(time) ;
		lv:long_name = "latent heat of vaporization" ;
		lv:units = "J/kg" ;
		lv:valid_min = 2400000.f ;
		lv:valid_max = 2600000.f ;
		lv:resolution = 10000.f ;
		lv:missing_value = -9999.f ;
	int qc_lv(time) ;
		qc_lv:long_name = "Quality check results on field: latent heat of vaporization" ;
		qc_lv:units = "unitless" ;
	float mr(time) ;
		mr:long_name = "mixing ratio" ;
		mr:units = "kg/kg" ;
		mr:valid_min = 0.f ;
		mr:valid_max = 0.067f ;
		mr:resolution = 0.0001f ;
		mr:missing_value = -9999.f ;
	int qc_mr(time) ;
		qc_mr:long_name = "Quality check results on field: mixing ratio" ;
		qc_mr:units = "unitless" ;
	float real_cp(time) ;
		real_cp:long_name = "0=real or 1=dummy value of cp" ;
		real_cp:units = "unitless" ;
		real_cp:missing_value = -9999.f ;
	float real_rho(time) ;
		real_rho:long_name = "0=real or 1=dummy value of rho" ;
		real_rho:units = "unitless" ;
		real_rho:missing_value = -9999.f ;
	float real_lv(time) ;
		real_lv:long_name = "0=real or 1=dummy value of lv" ;
		real_lv:units = "unitless" ;
		real_lv:missing_value = -9999.f ;
	float real_mr(time) ;
		real_mr:long_name = "0=real or 1=dummy value of mr" ;
		real_mr:units = "unitless" ;
		real_mr:missing_value = -9999.f ;
	float h(time) ;
		h:long_name = "sensible heat flux" ;
		h:units = "W/m^2" ;
		h:valid_min = -300.f ;
		h:valid_max = 1100.f ;
		h:resolution = 0.1f ;
		h:missing_value = -9999.f ;
	int qc_h(time) ;
		qc_h:long_name = "Quality check results on field: sensible heat flux" ;
		qc_h:units = "unitless" ;
	float lv_e(time) ;
		lv_e:long_name = "latent heat flux" ;
		lv_e:units = "W/m^2" ;
		lv_e:valid_min = -300.f ;
		lv_e:valid_max = 1100.f ;
		lv_e:resolution = 0.1f ;
		lv_e:missing_value = -9999.f ;
	int qc_lv_e(time) ;
		qc_lv_e:long_name = "Quality check results on field: latent heat flux" ;
		qc_lv_e:units = "unitless" ;
	float k(time) ;
		k:long_name = "momentum flux (dynamic)" ;
		k:units = "kg/(m s^2)" ;
		k:valid_max = 0.f ;
		k:resolution = 0.0001f ;
		k:missing_value = -9999.f ;
	int qc_k(time) ;
		qc_k:long_name = "Quality check results on field: momentum flux (dynamic)" ;
		qc_k:units = "unitless" ;
	float ustar(time) ;
		ustar:long_name = "friction velocity" ;
		ustar:units = "m/s" ;
		ustar:valid_min = 0.02f ;
		ustar:valid_max = 1.5f ;
		ustar:resolution = 0.01f ;
		ustar:missing_value = -9999.f ;
	int qc_ustar(time) ;
		qc_ustar:long_name = "Quality check results on field: friction velocity" ;
		qc_ustar:units = "unitless" ;
	float fc(time) ;
		fc:long_name = "CO2 flux" ;
		fc:units = "umol/(s m^2)" ;
		fc:valid_min = -35.f ;
		fc:valid_max = 35.f ;
		fc:resolution = 0.1f ;
		fc:missing_value = -9999.f ;
	int qc_fc(time) ;
		qc_fc:long_name = "Quality check results on field: CO2 flux" ;
		qc_fc:units = "unitless" ;
	float n_good_u(time) ;
		n_good_u:long_name = "number of valid u samples" ;
		n_good_u:units = "unitless" ;
		n_good_u:valid_min = 12000.f ;
		n_good_u:valid_max = 18100.f ;
		n_good_u:missing_value = -9999.f ;
	int qc_n_good_u(time) ;
		qc_n_good_u:long_name = "Quality check results on field: number of valid u samples" ;
		qc_n_good_u:units = "unitless" ;
	float n_good_v(time) ;
		n_good_v:long_name = "number of valid v samples" ;
		n_good_v:units = "unitless" ;
		n_good_v:valid_min = 12000.f ;
		n_good_v:valid_max = 18100.f ;
		n_good_v:missing_value = -9999.f ;
	int qc_n_good_v(time) ;
		qc_n_good_v:long_name = "Quality check results on field: number of valid v samples" ;
		qc_n_good_v:units = "unitless" ;
	float n_good_w(time) ;
		n_good_w:long_name = "number of valid w samples" ;
		n_good_w:units = "unitless" ;
		n_good_w:valid_min = 12000.f ;
		n_good_w:valid_max = 18100.f ;
		n_good_w:missing_value = -9999.f ;
	int qc_n_good_w(time) ;
		qc_n_good_w:long_name = "Quality check results on field: number of valid w samples" ;
		qc_n_good_w:units = "unitless" ;
	float n_good_t(time) ;
		n_good_t:long_name = "number of valid t samples" ;
		n_good_t:units = "unitless" ;
		n_good_t:valid_min = 12000.f ;
		n_good_t:valid_max = 18100.f ;
		n_good_t:missing_value = -9999.f ;
	int qc_n_good_t(time) ;
		qc_n_good_t:long_name = "Quality check results on field: number of valid t samples" ;
		qc_n_good_t:units = "unitless" ;
	float n_good_q(time) ;
		n_good_q:long_name = "number of valid q samples" ;
		n_good_q:units = "unitless" ;
		n_good_q:valid_min = 12000.f ;
		n_good_q:valid_max = 18100.f ;
		n_good_q:missing_value = -9999.f ;
	int qc_n_good_q(time) ;
		qc_n_good_q:long_name = "Quality check results on field: number of valid q samples" ;
		qc_n_good_q:units = "unitless" ;
	float n_good_c(time) ;
		n_good_c:long_name = "number of valid c samples" ;
		n_good_c:units = "unitless" ;
		n_good_c:valid_min = 12000.f ;
		n_good_c:valid_max = 18100.f ;
		n_good_c:missing_value = -9999.f ;
	int qc_n_good_c(time) ;
		qc_n_good_c:long_name = "Quality check results on field: number of valid c samples" ;
		qc_n_good_c:units = "unitless" ;
	float n_bad_u(time) ;
		n_bad_u:long_name = "number of bad or out of range u samples" ;
		n_bad_u:units = "unitless" ;
		n_bad_u:missing_value = -9999.f ;
	float n_bad_v(time) ;
		n_bad_v:long_name = "number of bad or out of range v samples" ;
		n_bad_v:units = "unitless" ;
		n_bad_v:missing_value = -9999.f ;
	float n_bad_w(time) ;
		n_bad_w:long_name = "number of bad or out of range w samples" ;
		n_bad_w:units = "unitless" ;
		n_bad_w:missing_value = -9999.f ;
	float n_bad_t(time) ;
		n_bad_t:long_name = "number of bad or out of range t samples" ;
		n_bad_t:units = "unitless" ;
		n_bad_t:missing_value = -9999.f ;
	float n_bad_q(time) ;
		n_bad_q:long_name = "number of bad or out of range q samples" ;
		n_bad_q:units = "unitless" ;
		n_bad_q:missing_value = -9999.f ;
	float n_bad_c(time) ;
		n_bad_c:long_name = "number of bad or out of range c samples" ;
		n_bad_c:units = "unitless" ;
		n_bad_c:missing_value = -9999.f ;
	float n_spk_u(time) ;
		n_spk_u:long_name = "number of u samples removed due to spikes" ;
		n_spk_u:units = "unitless" ;
		n_spk_u:missing_value = -9999.f ;
	float n_spk_v(time) ;
		n_spk_v:long_name = "number of v samples removed due to spikes" ;
		n_spk_v:units = "unitless" ;
		n_spk_v:missing_value = -9999.f ;
	float n_spk_w(time) ;
		n_spk_w:long_name = "number of w samples removed due to spikes" ;
		n_spk_w:units = "unitless" ;
		n_spk_w:missing_value = -9999.f ;
	float n_spk_t(time) ;
		n_spk_t:long_name = "number of t samples removed due to spikes" ;
		n_spk_t:units = "unitless" ;
		n_spk_t:missing_value = -9999.f ;
	float n_spk_q(time) ;
		n_spk_q:long_name = "number of q samples removed due to spikes" ;
		n_spk_q:units = "unitless" ;
		n_spk_q:missing_value = -9999.f ;
	float n_spk_c(time) ;
		n_spk_c:long_name = "number of c samples removed due to spikes" ;
		n_spk_c:units = "unitless" ;
		n_spk_c:missing_value = -9999.f ;
	float mean_spk_u(time) ;
		mean_spk_u:long_name = "mean value of \"spike\" u samples" ;
		mean_spk_u:units = "m/s" ;
		mean_spk_u:missing_value = -9999.f ;
	float mean_spk_v(time) ;
		mean_spk_v:long_name = "mean value of \"spike\" v samples" ;
		mean_spk_v:units = "m/s" ;
		mean_spk_v:missing_value = -9999.f ;
	float mean_spk_w(time) ;
		mean_spk_w:long_name = "mean value of \"spike\" w samples" ;
		mean_spk_w:units = "m/s" ;
		mean_spk_w:missing_value = -9999.f ;
	float mean_spk_t(time) ;
		mean_spk_t:long_name = "mean value of \"spike\" t samples" ;
		mean_spk_t:units = "K" ;
		mean_spk_t:missing_value = -9999.f ;
	float mean_spk_q(time) ;
		mean_spk_q:long_name = "mean value of \"spike\" q samples" ;
		mean_spk_q:units = "mmol/m^3" ;
		mean_spk_q:missing_value = -9999.f ;
	float mean_spk_c(time) ;
		mean_spk_c:long_name = "mean value of \"spike\" c samples" ;
		mean_spk_c:units = "mmol/m^3" ;
		mean_spk_c:missing_value = -9999.f ;
	float n_bad_son_ic(time) ;
		n_bad_son_ic:long_name = "number of samples with bad sonic status flag" ;
		n_bad_son_ic:units = "unitless" ;
		n_bad_son_ic:missing_value = -9999.f ;
	float n_bad_irga(time) ;
		n_bad_irga:long_name = "number of samples with \"IRGA hardware problem\" flag" ;
		n_bad_irga:units = "unitless" ;
		n_bad_irga:missing_value = -9999.f ;
	float n_bad_irga_light(time) ;
		n_bad_irga_light:long_name = "number of samples with IRGA optical path blocked flag" ;
		n_bad_irga_light:units = "unitless" ;
		n_bad_irga_light:missing_value = -9999.f ;
	float mean_cooler(time) ;
		mean_cooler:long_name = "average voltage of IRGA cooler" ;
		mean_cooler:units = "V" ;
		mean_cooler:missing_value = -9999.f ;
	float lat ;
		lat:long_name = "north latitude" ;
		lat:units = "degrees" ;
		lat:valid_min = -90.f ;
		lat:valid_max = 90.f ;
	float lon ;
		lon:long_name = "east longitude" ;
		lon:units = "degrees" ;
		lon:valid_min = -180.f ;
		lon:valid_max = 180.f ;
	float alt ;
		alt:long_name = "altitude" ;
		alt:units = "meters above Mean Sea Level" ;

// global attributes:
		:ingest_software = " ecor_ingest.c,v 1.17 2004/02/03 02:45:49 gaustad process-ingest-ecor_ingest-7.7-0 $" ;
		:proc_level = "b1" ;
		:input_source = "ecor6:/data/collection/sgp/sgpecorE6.00/2004_0615_0000_06.flx" ;
		:site_id = "sgp" ;
		:sample_int = "0.1 second" ;
		:averaging_int = "30" ;
		:serial_number = "6" ;
		:comment = "Sign conventions:  positive for upward vertical wind component and\n",
    "upward atmospheric fluxes.  Standard ARM site arrangement is sonic sensor \"North\" mark\n",
    "pointing along the boom to the tower; the boom is usually pointing due south; u wind component\n",
    "is north-south with positive toward the north; v wind component is east-west with positive\n",
    "toward the west.  NOTE:  no correction is made to convert u and v component into\n",
    "meteorological \"north\" and \"east\" wind components when tower boom is not aligned to south;\n",
    "u wind component is \"along boom\", v wind component is \"cross boom\".\n",
    "\n",
    "Eddy Correlation systems are used to obtain surface fluxes from winds\n",
    "flowing over crops.  They have been installed primarily at the down-wind\n",
    "edge of fields of crops.  This system is deployed along an east-west fence\n",
    "that separates pasture from wheat.  The fence heads north a short distance to\n",
    "the west.  Data for winds from 90 to 270 degrees are usually representative\n",
    "for flows over wheat.  The crop height, density, and condition varies\n",
    "seasonally.  A description of the crop condition can be found in the SURFCOND\n",
    "weekly reports.  There are buildings approximately  250 - 300 m to the south\n",
    "and south-south-west that could disturb the wind flows." ;
		:resolution_description = "The resolution field attributes refer to the number of significant\n",
    "digits relative to the decimal point that should be used in\n",
    "calculations.  Using fewer digits might result in greater uncertainty;\n",
    "using a larger number of digits should have no effect and thus is\n",
    "unnecessary.  However, analyses based on differences in values with\n",
    "a larger number of significant digits than indicated could lead to\n",
    "erroneous results or misleading scientific conclusions.\n",
    "\n",
    "resolution for lat= 0.001\n",
    "resolution for lon = 0.001\n",
    "resolution for alt = 1" ;
		:sensor_location = "Sensors height (above base \'alt\'): 3m" ;
		:instruments = "Anemometer: Gill Windmaster Pro; IRGA: LiCor LI-7500" ;
		:facility_id = "6" ;
		:IRGA_serial_number = "75H-0470" ;
		:sonic_serial_number = "P000062" ;
		:sonic_temperature_offset = "0.000000 K" ;
		:sonic_temperature_slope = "1.240000 K" ;
		:analog_min = "0.000000 V" ;
		:analog_max = "5.000000 V" ;
		:H2O_min = "0.000000" ;
		:H2O_max = "2000.000000" ;
		:CO2_min = "8.000000" ;
		:CO2_max = "32.000000" ;
		:irga_lag = "0.298000 s" ;
		:boom_direction = "0.000000 deg" ;
		:qc_method = "Standard Mentor QC" ;
		:Mentor_QC_Field_Information = "For each qc_<field> interpret the values as follows:\n",
    "\n",
    "Basic mentor QC checks (bit values):\n",
    "==========================================\n",
    "0x0 = value is within the specified range\n",
    "0x1 = value is equal to \'missing_value\'\n",
    "0x2 = value is less than the \'valid_min\'\n",
    "0x4 = value is greater than the \'valid_max\'\n",
    "0x8 = value failed the \'valid_delta\' check\n",
    "\n",
    "If the value is a \'missing_value\' no min, max, or delta checks are performed.\n",
    "\n",
    "The delta checks are done by comparing each data value to the one just\n",
    "prior to it in time. If a previous data value does not exist or is a\n",
    "\'missing_value\' the delta check will not be performed.\n",
    "\n",
    "Note that the delta computation for multi-dimensioned data compares the\n",
    "absolute value between points in the same spatial location to the previous\n",
    "point in time.\n",
    "\n",
    "If the associated non-QC field does not contain any mentor-specified minimum,\n",
    "maximum, or delta information a qc_field is not generated.\n",
    "" ;
		:zeb_platform = "sgp30ecorE6.b1" ;
		:history = "created by user dsmgr on machine left at 15-Jun-2004,2:10:17, using $State: ds-zebra-zeblib-4.13-0 $" ;
}
