#! /usr/bin/perl -w

package MISS_SFC_Converter;

##Module-------------------------------------------------------------------
# <p>The MISS_SFC_Converter converts the netCDF data from the EOL Mobile ISS
# platform into the ASCII QCF format.</p>
# 
# @author Joel Clawson
# @version TREX_2006 This conversion was originally developed for T-REX from
#    the T-REX version of the DRI conversion.
##Module-------------------------------------------------------------------
use strict;
use lib "/work/software/TREX/library/conversion_modules/Version6";
use lib "/net/work/software/TREX/library/conversion_modules/Version6";
use DpgCalculations;
use DpgDate;
use NetCDF;
use RecordMap;
use Precip::PrecipAccumulator;
use Station::ElevatedStationMap;
use Station::Station;
use Surface::QCFConstants;
use Surface::QCFSurfaceRecord;

$! = 1;

&main();

##-------------------------------------------------------------------------
# @signature void main()
# <p>Execute the script to run the conversion.</p>
##-------------------------------------------------------------------------
sub main {
    my $converter = MISS_SFC_Converter->new();
    $converter->convert();
    $converter->clean_empty_files();
}

##-------------------------------------------------------------------------
# @signature ISS_SFC_Converter new()
# <p>Create a new instance of the ISS_SFC_Converter class.  This defines
# the class and the constants used by the conversion.</p>
##-------------------------------------------------------------------------
sub new {
    my $invocant = shift;
    my $class = $invocant || ref($invocant);
    my $self = {};
    bless($self,$class);

    $self->{"stations"} = Station::ElevatedStationMap->new();
    $self->{"records"} = RecordMap->new();

    $self->{"NETWORK"} = "ISS05M";
    $self->{"PROJECT"} = "T-REX";

    $self->{"START_TOI"} = "2006/03/01";
    $self->{"END_TOI"} = "2006/04/30";

    $self->{"OUT_DIR"} = "../output";
    $self->{"FINAL_DIR"} = "../final";
    $self->{"RAW_DIR"} = "../raw_data";

    $self->{"DUPES_FILE"} = sprintf("%s/dupes.log",$self->{"OUT_DIR"});
    $self->{"SEQUENCE_FILE"} = sprintf("%s/sequence.log",$self->{"OUT_DIR"});
    $self->{"STN_SUM_FILE"} = sprintf("%s/station_summary.log",$self->{"OUT_DIR"});
    $self->{"warning_file"} = sprintf("%s/warning.log",$self->{"OUT_DIR"});
    $self->{"LOCATION_FILE"} = "../docs/trex_locations.txt";

    return $self;
}

##-------------------------------------------------------------------------
# @signature void check_for_duplicates()
# <p>Search the records generated by the conversion to see if duplicate
# records were found and print them to a duplicate log file.</p>
##-------------------------------------------------------------------------
sub check_for_duplicates {
    my ($self) = @_;
    
    open(my $DUPES,sprintf(">%s",$self->{"DUPES_FILE"})) or die("Can't create dupes file.\n");
    foreach my $dupe ($self->{"records"}->getDuplicateRecords()) {
        my $rec = $self->{"records"}->getRecord($dupe->getStationId(),$dupe->getNetworkId(),$dupe->getNominalDate(),$dupe->getNominalTime());

        if ($rec->toQCF_String(0) eq $dupe->toQCF_String(0)) {
            printf($DUPES "Exact duplicate found at %s in %s at %s %s.\n",$rec->getStationId(),$rec->getNetworkId(),$rec->getNominalDate(),$rec->getNominalTime());
        } else {
            printf($DUPES "Duplicate records found: %s %s at %s %s.  Keeping the first record.\n\t%s\t%s",$rec->getStationId(),$rec->getNetworkId(),$rec->getNominalDate(),$rec->getNominalTime(),$rec->toQCF_String(0),$dupe->toQCF_String(0));
        }
    }
    close($DUPES);
}

##-------------------------------------------------------------------------
# @signature void check_for_sequence_problems()
# <p>Check the records generated by the conversion to see if any of the
# expected records are missing.  The messages are placed into a sequence
# log file.</p>
##-------------------------------------------------------------------------
sub check_for_sequence_problems {
    my ($self) = @_;
    
    open (my $SEQ,sprintf(">%s",$self->{"SEQUENCE_FILE"})) or die("Can't create the sequence file.\n");
    print($SEQ $self->{"records"}->check5minuteSequence($self->{"START_TOI"},$self->{"END_TOI"}));
    close($SEQ);
}

##-------------------------------------------------------------------------
# @signature void clean_empty_files()
# <p>Remove all zero length log files and display a message to the user
# that the particular log was not generated.</p>
##-------------------------------------------------------------------------
sub clean_empty_files {
    my ($self) = @_;

    # Remove an empty warning file.
    if (-z $self->{"warning_file"}) {
	printf("There were not any warnings generated for the conversion.\n");
	unlink($self->{"warning_file"});
    }

    # Remove an empty duplicate record file.
    if (-z $self->{"DUPES_FILE"}) {
	printf("There were not any duplicate records found during the conversion.\n");
	unlink($self->{"DUPES_FILE"});
    }

    # Remove an empty sequence file.
    if (-z $self->{"SEQUENCE_FILE"}) {
	printf("There were not any missing records found during the conversion.\n");
	unlink($self->{"SEQUENCE_FILE"});
    }
}

##-------------------------------------------------------------------------
# @signature void convert()
# <p>Perform the conversion of the raw data to the QCF format.  This will
# generate the necessary directories, QCF data files, station lists, and
# other log files.</p>
##-------------------------------------------------------------------------
sub convert {
    my ($self) = @_;

    mkdir($self->{"OUT_DIR"}) unless(-e $self->{"OUT_DIR"});
    mkdir($self->{"FINAL_DIR"}) unless(-e $self->{"FINAL_DIR"});

    open($self->{"WARN"},">".$self->{"warning_file"}) or die("Can't create warning file.\n");

    $self->load_locations();
    $self->read_raw_files();
    $self->generate_output_files();
    $self->generate_station_files();

    close($self->{"WARN"});
}

##-------------------------------------------------------------------------
# @signature String clean_for_file_name(String text)
# <p>Remove/translate characters in a String so it can be used in a file name.</p>
# 
# @input $text The String to be cleaned.
# @output $text The cleaned up String.
##-------------------------------------------------------------------------
sub clean_for_file_name {
    my ($self,$text) = @_;
    
    # Convert spaces to underscores.
    $text =~ s/\s+/_/g;

    # Remove all hyphens
    $text =~ s/\-//g;

    return $text;
}

##-------------------------------------------------------------------------
# @signature void generate_output_files()
# <p>Generate the output files including the data file, duplicate record
# file, sequence problem file, and warning file.</p>
##-------------------------------------------------------------------------
sub generate_output_files {
    my ($self) = @_;

    printf("Generating output files...\n");

    # Generate the data file.
    my $outfile = sprintf("%s/%s.0qc",$self->{"OUT_DIR"},lc($self->clean_for_file_name($self->{"NETWORK"})));

#    open(my $ALL,">$outfile.all") or die("Can't create output file: $outfile\n");
    foreach my $record ($self->{"records"}->getAllRecords()) {
      if ($self->in_time_of_interest($record)) {
#	print($ALL $record->toQCF_String());

	my $min = substr($record->getNominalTime(),3,2);
	if ($min % 5 == 0) {
	  $record->setPrecip($self->{"accumulators"}->{$record->getStationId()}->getAccumulation($record->getNominalDate(),"YYYY/MM/DD",$record->getNominalTime(),"HH:MM"),"mm");
	} else {
	  $self->{"records"}->removeRecord($record->getStationId(),$record->getNetworkId(),
					   $record->getNominalDate(),$record->getNominalTime());
	}
      }
    }
#    close($ALL);

    # Check for problems with the records in the record map.
    $self->check_for_duplicates();
    $self->check_for_sequence_problems();

    open(my $OUT,">$outfile") or die("Can't create output file: $outfile\n");
    open(my $SINGLE,">$outfile.single") or die("Can't create output file: $outfile.single\n");
    foreach my $record ($self->{"records"}->getAllRecords()) {
        if ($self->in_time_of_interest($record)) {
            my $out = $record->toQCF_String();
            $out =~ s/ \-0\.00 /  0\.00 /g;
            print($OUT $out);
	    $self->{"stations"}->getStation($record->getStationId(),$self->{"NETWORK"},
					    $record->getLatitude(),$record->getLongitude(),
					    $record->getElevation())
	        ->insertDate($record->getNominalDate(),"YYYY/MM/DD");

	    $record->setStationId("MISS");
	    $out = $record->toQCF_String();
	    $out =~ s/ \-0\.00 /  0\.00 /g;
	    print($SINGLE $out);
        }
    }
    close($OUT);
    close($SINGLE);
}

##-------------------------------------------------------------------------
# @signature void generate_station_files()
# <p>Create the station list and the station summary files.</p>
##-------------------------------------------------------------------------
sub generate_station_files {
    my ($self) = @_;

    my $station_file = sprintf("%s/%s_%s_surface_stationCD.out",$self->{"FINAL_DIR"},
			       $self->clean_for_file_name($self->{"NETWORK"}),
			       $self->clean_for_file_name($self->{"PROJECT"}));
    open(my $STN,">$station_file") or die("Can't create station file: $station_file\n");
    foreach my $station ($self->{"stations"}->getAllStations()) {
	print($STN $station->toString()) unless ($station->getBeginDate() =~ /^9+$/);
    }
    close($STN);

    open(my $SUM,">".$self->{"STN_SUM_FILE"}) or die("Can't create the station summary file.\n");
    print($SUM $self->{"stations"}->getStationSummary());
    close($SUM);
}

##-------------------------------------------------------------------------
# @signature String[] getFields()
# <p>Get the list of variable fields to be retreived from the file.</p>
#
# @output $list The list of fields to be retreived from the file.
##-------------------------------------------------------------------------
sub getFields {
  return ("base_time","time","pres","tdry","rh","wspd","wdir","year","jd","hhmm","secs","rain","lat","lon","alt");
}

##-------------------------------------------------------------------------
# @signature int in_time_of_interest(Record record)
# <p>Determine if the current record is in the time of interest for the 
# current project.</p>
# 
# @input $record The record to be tested to be in the time of interest.
# @return $result <code>1</code> if the record is in the time of interest,
# <code>0</code> otherwise.
##-------------------------------------------------------------------------
sub in_time_of_interest {
    my ($self,$record) = @_;

    return compareDates($self->{"START_TOI"},"YYYY/MM/DD",$record->getNominalDate(),"YYYY/MM/DD") >= 0 && compareDates($record->getNominalDate(),"YYYY/MM/DD",$self->{"END_TOI"},"YYYY/MM/DD") >= 0;
}

sub is_missing {
    my ($value,$missing) = @_;

    my @miss = split("or",$missing);
    foreach my $miss_value (@miss) {
	return 1 if ($miss_value eq $value);
    }
    return 0;
}

sub load_locations {
    my ($self) = @_;

    open(my $LOC,$self->{"LOCATION_FILE"}) or die("Can't open locations file.\n");
    foreach my $line (<$LOC>) {
	chomp($line);
	my @data = split(/\;/,$line);

	my ($start_date,$start_time) = split(' ',$data[0]);
	my ($end_date,$end_time) = split(' ',$data[1]);

	my $end = sprintf("%s%s",$end_date,$end_time);
	$end =~ s/[\/\:]//g;
	my $current = sprintf("%s%s",$start_date,$start_time);
        $current =~ s/[\/\:]//g;

        while ($current <= $end) {
            my $key = sprintf("%s %s",$start_date,$start_time);
	    $self->{"locations"}->{$key}->{"id"} = $data[2];
	    $self->{"locations"}->{$key}->{"name"} = $data[3];
	    $self->{"locations"}->{$key}->{"lat"} = $data[4];
	    $self->{"locations"}->{$key}->{"lon"} = $data[5];
	    $self->{"locations"}->{$key}->{"elev"} = $data[6];

	    ($start_date,$start_time) = adjustDateTime($start_date,"YYYY/MM/DD",$start_time,"HH:MM",0,0,1,0);
	    $current = sprintf("%s%s",$start_date,$start_time);
	    $current =~ s/[\/\:]//g;
	}
    }
    close($LOC);
}

##-------------------------------------------------------------------------
# @signature void load_stations()
# <p>Load the stations where the data was collected from the station list.
##-------------------------------------------------------------------------
sub load_station {
    my ($self,$station_id,$name,$latitude,$longitude,$elevation) = @_;

    if (!defined($station_id)) {
	$station_id = "UNDEF";
	$name = "Not in T-REX List";
	$latitude = "-99.99999";
	$longitude = "-999.99999";
	$elevation = "-999.99";
	return undef();
    }

    my $station = $self->{"stations"}->getStation($station_id,$self->{"NETWORK"},
						  $latitude,$longitude,$elevation);

    if (!defined($station)) {
      $station = Station::Station->new($station_id,$self->{"NETWORK"});
      $station->setStationName(sprintf("%s %s",$station_id,$name));
      
      my $lat_fmt = $latitude < 0 ? "-" : "";
      while (length($lat_fmt) < length($latitude)) { $lat_fmt .= "D"; }
      my $lon_fmt = $longitude < 0 ? "-" : "";
      while (length($lon_fmt) < length($longitude)) { $lon_fmt .= "D"; }

      $station->setLatitude($latitude,$lat_fmt);
      $station->setLongitude($longitude,$lon_fmt);
      $station->setElevation($elevation,"m");

      $station->setLatLongAccuracy(4);
      $station->setStateCode("CA");
      $station->setReportingFrequency("1 minute");
      $station->setPlatformIdNumber(254);
      $station->setNetworkIdNumber(99);
      $station->setMobilityFlag("m");
            
      $self->{"stations"}->addStation($station);
    }

    return $station;
}

##-------------------------------------------------------------------------
# @signature String date, String format parse_date_time(String datetime)
# <p>Parse the date time into a seperate date and time values in a consistant
# format.  The date is to be in the YYYY-MM-DD format and the time is to be
# in the HH:MM:SS.S format.</p>
#
# @input $datetime The date/time value to be parsed.
# @return $date The date formatted into YYYY-MM-DD format.
# @return $time The time formatted into HH:MM:SS.S format.
##-------------------------------------------------------------------------
sub parse_date_time {
    my ($self,$datetime) = @_;

    # Remove quotes (typically surrounding the datetime value)
    $datetime =~ s/\"//g;
    # Force whole seconds to have the the decimal fraction included.
    if ($datetime =~ /\d{2}:\d{2}:\d{2}$/) { $datetime .= ".0"; }
    return split(' ',$datetime);
}

##-------------------------------------------------------------------------
# @signature void parse_raw_file(String file)
# <p>Process the file by parsing the raw data and converting it into the
# QCF format.</p>
#
# @input $file The full path to the file to be parsed.
##-------------------------------------------------------------------------
sub parse_raw_file {
    my ($self,$station_id,$file) = @_;

    printf("Processing file: %s...\n",$file);

    my $ncid = NetCDF::open($file,0);
    die("Unable to read netcdf file $file\n") if ($ncid == -1);

    #-----------------------------------------------------------------------
    # Find out the name of the record dimension ($recDimName) and how many
    # variables ($nvars) are in the input file. The other values read in are
    # not essential to this code, so identify them in case future mods need
    # them, then ignore them.
    #-----------------------------------------------------------------------
    my ($recDimName,$nvars,$dimsize) = &getFileStats($ncid,$ARGV);
    
    #-----------------------------------------------------------------------
    # If the number of records in the file is zero, then there is no data in
    # this file.  Warn the user and get the next file.
    #-----------------------------------------------------------------------
    if ($dimsize == 0) {
	print "WARNING: File $ARGV contains no records\n";
	return($dimsize,"0");
    }
    
    #-----------------------------------------------------------------------
    # Read in all the information about the variables in this NetCDF file,
    # i.e. variable name, type, dimensions, attributes.
    #-----------------------------------------------------------------------
    my %var = &getVariableDescriptions($ncid,$nvars,$ARGV);
    my $var = \%var;

    #---------------------------------------------------------------
    # Now read in the data for the variables we are interested in,
    # i.e. the variable we want to put out in the QCF record.
    # Data are in %{$variable}{values} where $variable is each parameter
    # name in &getFields.
    #---------------------------------------------------------------
    &getData($ncid,$recDimName, $var);
    
    #-----------------------------------------------------------------------
    # Let's make sure that all variable arrays are the same length.
    # Currently, all values for a single variable are in an array. In order
    # to successfully transform the matrix to get all values for a single
    # time into a record, we need to make sure our matrix is square and not
    # ragged.
    #
    # When we are done, we will have the correct lenght of the arrays, i.e.
    # the number of records in this file, stored in $arrayLen.
    #-----------------------------------------------------------------------

    # This has been commented out since the variables in the file do not
    # all have the same dimension and most are multi-dimensional.  This
    # check does not make sense in this context.
#    my @varList = &getFields;
#    my $arrayLen = scalar (@{$var{$varList[0]}{values}});
#    if ($arrayLen != $dimsize) {
#	print "ERROR: The number of records as listed in the record ";
#	print "dimension declaration at the top of the NetCDF file (=";
#	print "$dimsize) does not match the actual number of records for";
#	print " variable $varList[0] (=$arrayLen)\n";
#    }
#    my $variable;
#    foreach $variable (@varList) {
#	if ( scalar(@{$var{$variable}{values}}) != $arrayLen) {
#	    print "ERROR: Variable $variable has an incorrect number of ";
#	    print "values: ".scalar(@{$var{$variable}{values}})." Should ";
#	    print "be $arrayLen\n";
#	    exit(1);
#	}
#    }
    
    #-------------------------------------
    # All done.  Close the input file
    #-------------------------------------
    
    if (NetCDF::close($ncid) == -1) {
	die "Can't close $ARGV:$!\n";
    }

    
    for (my $time_index = 0; $time_index < $var->{"time"}{"time"}; $time_index++) {
      # Determine the time the readings were recorded.
      my ($date,$time) = getDateFromSeconds($var->{"base_time"}{"values"}[0] + 
					    $var->{"time"}{"values"}[$time_index]);

      my $fulldate = formatDate(sprintf("%04d%03d",
					$var->{"year"}{"values"}[$time_index],
					$var->{"jd"}{"values"}[$time_index]),
				"YYYYJJJ","YYYY/MM/DD");
      my $fulltime = formatTime(sprintf("%04d:%02d",
					$var->{"hhmm"}{"values"}[$time_index],
					$var->{"secs"}{"values"}[$time_index]),
				"HHMM:SS","HH:MM:SS");

      if ($date ne $fulldate || $time ne $fulltime) {
	printf("Date/Time Mismatch:\n\tUnix Time: %s %s\n\tJulian: %s %s\n\n",
	       $date,$time,$fulldate,$fulltime);
	exit(1);
      }

      # Determine the station the readings were recorded at.
      #my $key = sprintf("%s %s:00",$fulldate,substr($fulltime,0,2));
      my $key = sprintf("%s %s",$fulldate,substr($fulltime,0,5));

      #printf("Key: %s\n",$key);

      my $station = $self->load_station($self->{"locations"}->{$key}->{"id"},
					$self->{"locations"}->{$key}->{"name"},
					$self->{"locations"}->{$key}->{"lat"},
					$self->{"locations"}->{$key}->{"lon"},
					$self->{"locations"}->{$key}->{"elev"});
      next if (!defined($station));      


      if (!defined($self->{"accumulators"}->{$station->getStationId()})) {
	  $self->{"accumulators"}->{$station->getStationId()} = 
	      Precip::PrecipAccumulator->new($self->{"WARN"},1,5,$MISSING);
      }
   

      my $record = Surface::QCFSurfaceRecord->new($self->{"WARN"},$station);
      $record->setReadingTime($date,"YYYY/MM/DD",$time,"HH:MM:SS",0);

      foreach my $field (&getFields()) {
	
	# Ignore all of these fields since they are handled in other places.
	if ($field eq "time" || $field eq "base_time" || $field eq "alt" || 
	    $field eq "lat" || $field eq "lon" || $field eq "year" ||
	    $field eq "jd" || $field eq "hhmm" || $field eq "secs" || 
	    !defined($var->{$field})) {
	  next;
	}

	# Pull out the necessary information for the field.
	my $value = $var->{$field}{"values"}[$time_index];
	my $missing = $var->{$field}{"missing_value"};
	my $units = trim($var->{$field}{"units"});
	$units =~ s/degC/C/;
	$units =~ s/meters second\-1/m\/s/;

	# Ignore any missing values.
	if (!defined($missing) || !is_missing($value,$missing)) {
	  
	  # Manually define the units for precip if not already defined.
	  if ($units eq "" && $field eq "rain") {
	    $units = "mm";
	  }
	  
	  # Assign the value to correct measurement.
	  $record->setPressure($value,$units) if ($field eq "pres");
	  $record->setRelativeHumidity($value) if ($field eq "rh" && $units eq "%");
	  $record->setTemperature($value,$units) if ($field eq "tdry");
	  if ($field eq "rain") {
	    $record->setPrecip($value,$units);
	    $self->{"accumulators"}->{$station->getStationId()}->addPrecip($record->getActualDate(),"YYYY/MM/DD",
									   $record->getActualTime(),"HH:MM",
									   $record->getPrecip());
	  }
	  $record->setWindSpeed($value,$units) if ($field eq "wspd");
	  $record->setWindDirection($value) if ($field eq "wdir" && $units =~ /^deg/i);
	}
      }

      $self->update_for_TREX($record) if ($self->{"PROJECT"} =~ /T\-?REX/);
      
      $self->{"records"}->addRecord($record);
    }
}

##-------------------------------------------------------------------------
# @signature void read_raw_files()
# <p>Read in the list of raw data files in the raw data directory and 
# parse them into the QCF format.</p>
##-------------------------------------------------------------------------
sub read_raw_files {
  my ($self) = @_;
  
  opendir(my $RAW,$self->{"RAW_DIR"}) or die("Unable to read raw directory: ".$self->{"RAW_DIR"}."\n");
  my @dirs = sort(readdir($RAW));
  closedir($RAW);
  
  foreach my $dir (@dirs) {
    next if ($dir =~ /^\.+$/);
    
    opendir(my $RAWDIR,sprintf("%s/%s",$self->{"RAW_DIR"},$dir)) or 
      die("Unable to read raw directory: ".$self->{"RAW_DIR"}."/$dir\n");
    my @files = sort(grep(/\.nc$/,readdir($RAWDIR)));
    closedir($RAWDIR);
    
    foreach my $file (@files) {
      $self->parse_raw_file($dir,sprintf("%s/%s/%s",$self->{"RAW_DIR"},$dir,$file));
    }
  }
}

sub trim {
  my ($data) = @_;
  $data =~ s/\0//g;
  $data =~ s/^\s+//;
  $data =~ s/\s+$//;
  return $data;
}

##-------------------------------------------------------------------------
# @signature void update_for_TREX(QCFSurfaceRecord record)
# <p>Update the specified record for changes that only apply during the
# T-REX project.</p>
#
# @input $record The record to be updated.
##-------------------------------------------------------------------------
sub update_for_TREX {
    my ($self,$record) = @_;

    my $nominal = sprintf("%s%s",$record->getNominalDate(),$record->getNominalTime());
    $nominal =~ s/[\/:]//g;

    if ($nominal == 200603262300) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
        $record->setDewPointFlag($BAD_FLAG) if ($record->getDewPoint() != $MISSING);
    } elsif (200603260305 <= $nominal && $nominal <= 200603262300) {
        $record->setWindSpeedFlag($BAD_FLAG) if ($record->getWindSpeed() != $MISSING);
        $record->setWindDirectionFlag($BAD_FLAG) if ($record->getWindDirection() != $MISSING);
        $record->setPressureFlag($DUBIOUS_FLAG) if ($record->getPressure() != $MISSING);
        $record->setCalcSeaLevelPressureFlag($DUBIOUS_FLAG) if ($record->getCalcSeaLevelPressure() != $MISSING);
        $record->setTemperatureFlag($DUBIOUS_FLAG) if ($record->getTemperature() != $MISSING);
        $record->setDewPointFlag($DUBIOUS_FLAG) if ($record->getDewPoint() != $MISSING);
        $record->setPrecipFlag($DUBIOUS_FLAG) if ($record->getPrecip() != $MISSING);
    } elsif (200603280005 <= $nominal && $nominal <= 200603292135) {
        $record->setWindSpeedFlag($BAD_FLAG) if ($record->getWindSpeed() != $MISSING);
        $record->setWindDirectionFlag($BAD_FLAG) if ($record->getWindDirection() != $MISSING);
    } elsif (200603280815 <= $nominal && $nominal <= 200603282250) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
        $record->setDewPointFlag($BAD_FLAG) if ($record->getDewPoint() != $MISSING);
        $record->setPressureFlag($BAD_FLAG) if ($record->getPressure() != $MISSING);
    } elsif (200603200145 <= $nominal && $nominal <= 200603200155) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
    } elsif (200603200220 == $nominal) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
        $record->setDewPointFlag($BAD_FLAG) if ($record->getDewPoint() != $MISSING);
    } elsif (200603200225 == $nominal) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
    } elsif (200604072135 == $nominal) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
    } elsif (200604122245 == $nominal) {
        $record->setTemperatureFlag($BAD_FLAG) if ($record->getTemperature() != $MISSING);
    }
}






##------------------------------------------------------------------------------
# @signature void getFileStats($ARGV)
# <p>Find out the name of the record dimension and how many variables ($nvars)
# are in the input file. The other values read in are not essential to this
# code, so identify them in case future mods need them, then ignore them.
#
# @input  $ncid - the NetCDF ID of the input file from the previous call to
#                 nc_open
# @input  $ARGV - the name of the input file.  Used for error reporting only.
#
# @output $recDimName - the name of the record dimension.
# @output $nvars - the number of variables in the input file.
# @output $dimsize - the number of records in the file
##------------------------------------------------------------------------------
sub getFileStats {
    my $ncid = shift;
    my $input_file = shift;
    
    my $ndims;          # The number of dimensions defined for this NetCDF
                        # input file.
    my $nvars;          # The number of variables defined for this file.
    my $natts;          # The number of global attributes defined for this file.
    my $recdim;         # A pointer to which dimension is the record dimension.
                        # The record dimension is the dimension that contains
                        # an integer giving the number of records in the file.
                        # It is defined dynamically when the file is
                        # written and can grow or shrink as necessary.
    my $recDimName;     # The name of the record dimension.
    my $dimsize;        # The number saved in the record dimension = the number
                        # of records in the file.

    # NetCDF::inquire()
    # Inquire of a NetCDF file how many dimensions, variable, and global
    # attributes it has, and which dimension is it's record dimension.
    #
    # @input - the NetCDF id of the file
    #
    # @output - the number of dimensions, variables, and global attributes
    #           in the file, and the location of the file's record dimension.

    if (NetCDF::inquire($ncid,$ndims,$nvars,$natts,$recdim) == -1) {
        die "Can't inquire of $input_file:$!\n";
    }

    # NetCDF::diminq
    # Inquire of a NetCDF dimension, it's name and size, given a pointer to it.
    #
    # @input - the NetCDF id of the file
    # @input - the location of the file's record dimension
    #
    # @output - the name of the file's record dimension
    # @output - the size of the file's record dimension

    if (NetCDF::diminq($ncid,$recdim,$recDimName,$dimsize) == -1) {
        die "Can't inquire record dimension of $input_file:$!\n";
    }



#    if (&DEBUGFileStats) {
#        print "The id assigned to $input_file is $ncid\n";
#        print "The total number of dimensions in $input_file is $ndims\n";
#        print "The total number of variables in $input_file is $nvars\n";
#        print "The total number of attributes in $input_file is $natts\n";
#        print "The name of the record dimension is $recDimName\n";
#        print "The size of the record dimension is $dimsize\n";
#    }

    return($recDimName,$nvars,$dimsize);
}
##--------------------------------------------------------------------
# @signature void getVariableDescriptions()
# <p>Read in all the information about the variables in this NetCDF file,
# i.e. variable name, type, dimensions, attributes. Each variable has an
# associated table of information specifying attributes of that variable,
# i.e., the ID of the variable (uniquely specifies this variable - like a
# pointer to that variable), the data type of the data stored in the variable
# (char, float, etc), the number of dimensions of this variable (does it
# contain a scalar, an array, a matrix), the name and size of each dimension,
# and how many other attributes there are, and what they are, i.e. a long
# name for the variable, the units the data in the variable are in, how missing
# is defined, etc.
#
# @input  $ncid - the file id of the input file.
# @input  $nvars
# @input  $ARGV - the name of the input file.  Used for error reporting only.
#
# @output  %{$name} Returns a hash for each variable name that contains:
# <ul>
#    <li> $name = latitude,
#    <li> $var{latitude}{varid} = 22;
#    <li> $var{latitude}{datatype} = float,
#    <li> $var{latitude}{ndims} = 1 ( ${latitude}{recNum}=8446 )
#    <li> $var{latitude}{dimname}[0] = recNum;
#    <li> $var{latitude}{natts} = 5
#    <li> $var{latitude}{long_name} = "latitude"
#    <li> $var{latitude}{units} = "degree_north"
#    <li> $var{latitude}{_FillValue} = 3.40282346638529e+38
#    <li> $var{latitude}{missing_value} = -9999
#    <li> $var{latitude}{reference} = "station table"
# </ul>
#
##--------------------------------------------------------------------
sub getVariableDescriptions {
    my $ncid = shift;
    my $nvars = shift;

    # The NetCDF files encode the data types as a char. Use this hash to
    # unencode these types.
    my %data_types = (2,'char',3,'short',4,'int',5,'float',6,'double');

    # Create a hash for
    # this variable to store all the information about the variable.
    my %var = ();

    # Loop through all the variables in the NetCDF input file.
    for (my $varid = 0;$varid <$nvars; $varid++) {
        my @dimids;

        # Given the NetCDF file ID and the variable ID, find out the variable
        # name, the data type the data is stored as (float, etc), the number
        # of dimensions of this variable, an array of pointers to the dimensions
        # and the number of variable attributes assigned to this variable.
        NetCDF::varinq($ncid,$varid, my $name, my $datatype,my $ndims,\@dimids,
                        my $natts);

        # Now that $name contains the name of the variable, assign all the
        # information about the variable to the hash $var{$name}
        $var{$name}{varid} = $varid;
        $var{$name}{datatype} = $data_types{$datatype};
        $var{$name}{ndims} = $ndims;

        #if (&DEBUGgetV) {print "variable # $varid:\n\tname = $name,";}
        #if (&DEBUGgetV) {print "\n\tdata type = $var{$name}{datatype},\n\t";}
        #if (&DEBUGgetV) {print "number of dimensions = $var{$name}{ndims} ( ";}

        # Loop through each of the dimensions of the variable and determine
        # the dimension name and size.
        for (my $dim = 0;$dim <$var{$name}{ndims}; $dim++) {
            NetCDF::diminq($ncid,$dimids[$dim],my $dimname,my $dimsize);
	      $var{$name}{dimname}[$dim] = $dimname;
	      $var{$name}{$dimname} = $dimsize;
	      #if (&DEBUGgetV) {print "$dimname=$var{$name}{$dimname} ";}
        }

        # Assign the information on the number of attributes to the hash.
        $var{$name}{natts} = $natts;
        #if (&DEBUGgetV) {print ")\n\tNumber of attributes = $var{$name}{natts}\n";}

        # Loop through each of the attributes assigned to this variable and
        # determine the attribute name, type, length, and value.
        for (my $attnum = 0;$attnum <$var{$name}{natts}; $attnum++) {

            # determine attribute name
            my $attname;
            if (NetCDF::attname($ncid,$varid,$attnum,$attname) == -1) {
                die "Can't inquire of attribute name of $ARGV:$!\n";
            }

            # determine attribute data type and length
            my ($atttype, $attlen);
            if (NetCDF::attinq($ncid,$varid,$attname,$atttype,$attlen) == -1) {
                die "Can't inquire of attribute type of $ARGV:$!\n";
            }
            #if (&DEBUGgetV) {print "\t$attname length = $attlen\n";}
            $var{$name}{$attname}{attlen} = $attlen;

            # Convert the attribute type from a number to a descriptive string.
            $var{$name}{atttype} = $data_types{$atttype};

            # determine the attribute value.  The values is read in as an array
            # of numbers.  If the attribute contains a string, the numbers
            # represent chars and we need to pack the chars together to get the
            # string.  If the attribute contains a number, then it should be the
            # first value in the array.
            my @value;
            if (NetCDF::attget($ncid,$varid,$attname,\@value) == -1) {
                die "Can't inquire of value of attribute of $ARGV:$!\n";
            }

            if ($var{$name}{atttype} eq "char") {
                my $str = pack("C*",@value);
                $var{$name}{$attname} = $str;
                #if (&DEBUGgetV)
                #    {print "\t$attname = \"$var{$name}{$attname}\"\n";}
            } elsif ($var{$name}{atttype} eq "int" ||
                     $var{$name}{atttype} eq "short" ||
                     $var{$name}{atttype} eq "float" ||
                     $var{$name}{atttype} eq "double") {
                if ($var{$name}{$attname}{attlen} == 1)
                    {$var{$name}{$attname} = $value[0];}
		elsif ($var{$name}{$attname}{attlen} == 2 && 
		       $name =~ /(lat)|(lon)/ && $attname eq "valid_range") {
		  # Ignore 
		}
                else
                    {
                    print "WARNING: Attribute $attname has length > 1: ";
                    print "$var{$name}{$attname}{attlen}\n";
                    exit(1);
                    }
                #if (&DEBUGgetV) {print "\t$attname = $var{$name}{$attname}\n";}
            } else {
                print "WARNING: Unknown attribute type $var{$name}{atttype}\n";
                exit(1);
            }
        }
    }
    return(%var);
}

##--------------------------------------------------------------------
# @signature void getData()
# <p>Read in all the data for each variable that occurs in the QCF output
# i.e. time, station info, temperature, dewpoint, etc.
# Ignore other variables
#
# @output  %var{$variable}{values} Adds the array values to the hash for
#       each variable
##--------------------------------------------------------------------
sub getData {
    my $ncid = shift;
    my $recDimName = shift;
    my $var = shift;

    my $variable;

    foreach $variable (&getFields) {

      next if !defined($var->{$variable});

      #-------------------------------------------------------------------
      # If the variable has no dimension, read in the single value.
      #-------------------------------------------------------------------
      if ($var->{$variable}{ndims} == 0) {
	my @values;
	if (NetCDF::varget($ncid,$var->{$variable}{varid},0,1,\@values) == -1) {
	  die("Can't get data for variable $variable: $!\n");
	}
	$var->{$variable}{values}[0] = $values[0];
      #---------------------------------------------------------------------
      # If the variable has only one dimension, and that dimension is the
      # record dimension, then read it in.
      #---------------------------------------------------------------------
      } elsif ($var->{$variable}{ndims} == 1) {
	my @values;
	my @flags;
	for (my $recnum=0;$recnum<$var->{$variable}{$var->{$variable}{dimname}[0]};$recnum++) {
	  if (NetCDF::varget($ncid,$var->{$variable}{varid},$recnum,1,
			     \@values) == -1) {
	    die "Can't get data for variable $variable:$!\n";
	  }
	  $var->{$variable}{values}[$recnum] = $values[0];
	  #if (&DEBUGgetData) {
	  #   print "$recnum $variable $var->{$variable}{values}[$recnum]\n";
	  #}
	}
	
        #---------------------------------------------------------------------
        # If the variable has two dimensions, the type is character, and the
        # first dimension is the record dimension, then assume the second
        # dimension is the string length and read it in.
        #---------------------------------------------------------------------
      } elsif ($var->{$variable}{ndims} == 2 &&
	       $var->{$variable}{datatype} eq "char"){
	my $varLenName = $var->{$variable}{dimname}[1];
	my $varLen = $var->{$variable}{$varLenName};
	my @values = "";
	for (my $recnum=0;$recnum < $var->{$variable}{$var->{$variable}{dimname}[0]};$recnum++) {
	  if (NetCDF::varget($ncid,$var->{$variable}{varid},[$recnum,0],
			     [1,$varLen], \@values) == -1) {
	    die "Can't get data for variable $variable:$!\n";
	  }
	  # In Perl, the command:
	  #
	  #    pack("C", $x)
	  #
	  # where $x is either less than 0 or more than 255 returns the
	  # error "Character in 'C' format wrapped in pack at madis.pl line
	  # ####." ; the "C" format is only for encoding native operating
	  # system characters (ASCII, EBCDIC, and so on) and not for Unicode
	  # characters, so Perl behaved as if you meant
	  #
	  #        pack("C", $x & 255)
	  # If you actually want to pack Unicode codepoints, use the "U"
	  # format instead.
	  # This information was downloaded from the Perl Diagnostics
	  # webpage (perldiag) http://perldoc.perl.org/perldiag.html
	  # accessed 11/2/2006.
	  my $teststr = pack("U*",@values);
	  my $str = pack("C*",@values);
	  if ($teststr ne $str) {print STDERR $str."\n";}

	  $str =~ s/\0//g;
	  $var->{$variable}{values}[$recnum] = $str;

	  #if (&DEBUGgetData) {
	  #    print
	  #    "$recnum $variable $var->{$variable}{values}[$recnum]\n";
	  #}
	}
	
	#-------------------------------------------------------------------
	# If the data are in a two-dimensional data matrix then read it in.
	#-------------------------------------------------------------------
      } elsif ($var->{$variable}{ndims} == 2) {
	my @values;
	for (my $i = 0; $i < $var->{$variable}{$var->{$variable}{dimname}[0]}; $i++) {
	  for (my $j = 0; $j < $var->{$variable}{$var->{$variable}{dimname}[1]}; $j++) {
	    if (NetCDF::varget($ncid,$var->{$variable}{varid},[$i,$j],[1,1],\@values) == -1) {
	      die("Can't get data for variable $variable: $!\n");
	    }

	    $var->{$variable}{values}[$i][$j] = $values[0];
	  }
	}
	
        #---------------------------------------------------------------------
        # Otherwise, warn the user that we don't know how to read in the
        # variable.
        #---------------------------------------------------------------------
      } else {
	print "CRITICAL ERROR: Don't know how to read in variable: $variable(";
	for (my $dim = 0;$dim <$var->{$variable}{ndims}; $dim++) {
	  my $dimname = $var->{$variable}{dimname}[$dim];
	  print "$var->{$variable}{dimname}[$dim]=$var->{$variable}{$dimname} ";
	}
	print ")\n";
      }
    }
}
