#! /usr/bin/perl -w

package GBUAPCD_SFC_Converter;

##Module-------------------------------------------------------------------
# <p>The GBUAPCD_SFC_Converter converts the source ASCII format from the
# Great Basin Unified Air Pollution Control District into the QCF format.</p>
# 
# @author Joel Clawson
# @version TREX_2006 This conversion was originally developed for T-REX from
#    the T-REX version of the DRI conversion.
##Module-------------------------------------------------------------------
use strict;
use lib "/work/software/TREX/library/conversion_modules/Version6";
use lib "/net/work/software/TREX/library/conversion_modules/Version6";
use DpgCalculations;
use DpgDate;
use RecordMap;
use Station::PositionedStationMap;
use Station::Station;
use Surface::QCFConstants;
use Surface::QCFSurfaceRecord;

$! = 1;

&main();

##-------------------------------------------------------------------------
# @signature void main()
# <p>Execute the script to run the conversion.</p>
##-------------------------------------------------------------------------
sub main {
    my $converter = GBUAPCD_SFC_Converter->new();
    $converter->convert();
    $converter->clean_empty_files();
}

##-------------------------------------------------------------------------
# @signature GBUAPCD_SFC_Converter new()
# <p>Create a new instance of the GBUAPCD_SFC_Converter class.  This defines
# the class and the constants used by the conversion.</p>
##-------------------------------------------------------------------------
sub new {
    my $invocant = shift;
    my $class = $invocant || ref($invocant);
    my $self = {};
    bless($self,$class);

    $self->{"stations"} = Station::PositionedStationMap->new();
    $self->{"records"} = RecordMap->new();
    $self->{"record_times"} = {};

    $self->{"NETWORK"} = "GBUAPCD60";
    $self->{"PROJECT"} = "T-REX";

    $self->{"START_TOI"} = "2006/03/01";
    $self->{"END_TOI"} = "2006/04/30";

    $self->{"OUT_DIR"} = "../output";
    $self->{"FINAL_DIR"} = "../final";
    $self->{"RAW_DIR"} = "../raw_data";

    $self->{"DUPES_FILE"} = sprintf("%s/dupes.log",$self->{"OUT_DIR"});
    $self->{"SEQUENCE_FILE"} = sprintf("%s/sequence.log",$self->{"OUT_DIR"});
    $self->{"STN_SUM_FILE"} = sprintf("%s/station_summary.log",$self->{"OUT_DIR"});
    $self->{"warning_file"} = sprintf("%s/warning.log",$self->{"OUT_DIR"});

    return $self;
}

##-------------------------------------------------------------------------
# @signature void check_for_duplicates()
# <p>Search the records generated by the conversion to see if duplicate
# records were found and print them to a duplicate log file.</p>
##-------------------------------------------------------------------------
sub check_for_duplicates {
    my ($self) = @_;
    
    open(my $DUPES,sprintf(">%s",$self->{"DUPES_FILE"})) or die("Can't create dupes file.\n");
    foreach my $dupe ($self->{"records"}->getDuplicateRecords()) {
        my $rec = $self->{"records"}->getRecord($dupe->getStationId(),$dupe->getNetworkId(),$dupe->getNominalDate(),$dupe->getNominalTime());

        if ($rec->toQCF_String(0) eq $dupe->toQCF_String(0)) {
            printf($DUPES "Exact duplicate found at %s in %s at %s %s.\n",$rec->getStationId(),$rec->getNetworkId(),$rec->getNominalDate(),$rec->getNominalTime());
        } else {
            printf($DUPES "Duplicate records found: %s %s at %s %s.  Keeping the first record.\n\t%s\t%s",$rec->getStationId(),$rec->getNetworkId(),$rec->getNominalDate(),$rec->getNominalTime(),$rec->toQCF_String(0),$dupe->toQCF_String(0));
        }
    }
    close($DUPES);
}

##-------------------------------------------------------------------------
# @signature void check_for_sequence_problems()
# <p>Check the records generated by the conversion to see if any of the
# expected records are missing.  The messages are placed into a sequence
# log file.</p>
##-------------------------------------------------------------------------
sub check_for_sequence_problems {
    my ($self) = @_;
    
    open (my $SEQ,sprintf(">%s",$self->{"SEQUENCE_FILE"})) or die("Can't create the sequence file.\n");
    print($SEQ $self->{"records"}->check5minuteSequence($self->{"START_TOI"},$self->{"END_TOI"}));
    close($SEQ);
}

##-------------------------------------------------------------------------
# @signature void clean_empty_files()
# <p>Remove all zero length log files and display a message to the user
# that the particular log was not generated.</p>
##-------------------------------------------------------------------------
sub clean_empty_files {
    my ($self) = @_;

    # Remove an empty warning file.
    if (-z $self->{"warning_file"}) {
	printf("There were not any warnings generated for the conversion.\n");
	unlink($self->{"warning_file"});
    }

    # Remove an empty duplicate record file.
    if (-z $self->{"DUPES_FILE"}) {
	printf("There were not any duplicate records found during the conversion.\n");
	unlink($self->{"DUPES_FILE"});
    }

    # Remove an empty sequence file.
    if (-z $self->{"SEQUENCE_FILE"}) {
	printf("There were not any missing records found during the conversion.\n");
	unlink($self->{"SEQUENCE_FILE"});
    }
}

##-------------------------------------------------------------------------
# @signature void convert()
# <p>Perform the conversion of the raw data to the QCF format.  This will
# generate the necessary directories, QCF data files, station lists, and
# other log files.</p>
##-------------------------------------------------------------------------
sub convert {
    my ($self) = @_;

    mkdir($self->{"OUT_DIR"}) unless(-e $self->{"OUT_DIR"});
    mkdir($self->{"FINAL_DIR"}) unless(-e $self->{"FINAL_DIR"});

    open($self->{"WARN"},">".$self->{"warning_file"}) or die("Can't create warning file.\n");

    $self->read_raw_files();
    $self->generate_output_files();
    $self->generate_station_files();

    close($self->{"WARN"});
}

##-------------------------------------------------------------------------
# @signature String clean_for_file_name(String text)
# <p>Remove/translate characters in a String so it can be used in a file name.</p>
# 
# @input $text The String to be cleaned.
# @output $text The cleaned up String.
##-------------------------------------------------------------------------
sub clean_for_file_name {
    my ($self,$text) = @_;
    
    # Convert spaces to underscores.
    $text =~ s/\s+/_/g;

    # Remove all hyphens
    $text =~ s/\-//g;

    return $text;
}

##-------------------------------------------------------------------------
# @signature void generate_output_files()
# <p>Generate the output files including the data file, duplicate record
# file, sequence problem file, and warning file.</p>
##-------------------------------------------------------------------------
sub generate_output_files {
    my ($self) = @_;

    printf("Generating output files...\n");

    # Check for problems with the records in the record map.
    $self->check_for_duplicates();
    $self->check_for_sequence_problems();

    # Generate the data file.
    my $outfile = sprintf("%s/%s.0qc",$self->{"OUT_DIR"},lc($self->clean_for_file_name($self->{"NETWORK"})));
    open(my $OUT,">$outfile") or die("Can't create output file: $outfile\n");
    foreach my $record ($self->{"records"}->getAllRecords()) {
        if ($self->in_time_of_interest($record)) {
            my $out = $record->toQCF_String();
            $out =~ s/ \-0\.00 /  0\.00 /g;
            print($OUT $out);
	    $self->{"stations"}->getStation($record->getStationId(),$self->{"NETWORK"},
					    $record->getLatitude(),$record->getLongitude())
	        ->insertDate($record->getNominalDate(),"YYYY/MM/DD");
        }
    }
    close($outfile);
}

##-------------------------------------------------------------------------
# @signature void generate_station_files()
# <p>Create the station list and the station summary files.</p>
##-------------------------------------------------------------------------
sub generate_station_files {
    my ($self) = @_;

    my $station_file = sprintf("%s/%s_%s_surface_stationCD.out",$self->{"FINAL_DIR"},
			       $self->clean_for_file_name($self->{"NETWORK"}),
			       $self->clean_for_file_name($self->{"PROJECT"}));
    open(my $STN,">$station_file") or die("Can't create station file: $station_file\n");
    foreach my $station ($self->{"stations"}->getAllStations()) {
	print($STN $station->toString()) unless ($station->getBeginDate() =~ /^9+$/);
    }
    close($STN);

    open(my $SUM,">".$self->{"STN_SUM_FILE"}) or die("Can't create the station summary file.\n");
    print($SUM $self->{"stations"}->getStationSummary());
    close($SUM);
}

##-------------------------------------------------------------------------
# @signature int in_time_of_interest(Record record)
# <p>Determine if the current record is in the time of interest for the 
# current project.</p>
# 
# @input $record The record to be tested to be in the time of interest.
# @return $result <code>1</code> if the record is in the time of interest,
# <code>0</code> otherwise.
##-------------------------------------------------------------------------
sub in_time_of_interest {
    my ($self,$record) = @_;

    return compareDates($self->{"START_TOI"},"YYYY/MM/DD",$record->getNominalDate(),"YYYY/MM/DD") >= 0 && compareDates($record->getNominalDate(),"YYYY/MM/DD",$self->{"END_TOI"},"YYYY/MM/DD") >= 0;
}

##-------------------------------------------------------------------------
# @signature Hash parse_header(String header_line)
# <p>Parse out the indicies and units of the data from the header line.</p>
#
# @input $header_line The line containing the header information.
# @output $header A Hash containing the index and units for each measurement
#   in the header line.
##-------------------------------------------------------------------------
sub parse_header {
  my ($self,$header_line) = @_;
  my $header = {};

  chomp($header_line);
  my @data = split(/,/,$header_line);

  for (my $i = 0; $i < @data; $i++) {
    $data[$i] = trim($data[$i]);

    # Check for a header that contains the date.
    if ($data[$i] =~ /^date$/i) {
      $header->{"date"}->{"index"} = $i;
    } 
    # Check for a header that contains the hour.
    elsif ($data[$i] =~ /^hour$/i) {
      $header->{"time"}->{"index"} = $i;
    }
    # Check for a header part that contains the wind speed.
    elsif ($data[$i] =~ /^10\-m avg wind spd \((.+)\)$/i) {
      $header->{"wind_spd"}->{"index"} = $i;
      $header->{"wind_spd"}->{"unit"} = $1;
    }
    # Check for a header part that contains the wind direction.
    elsif ($data[$i] =~ /^10\-m avg wind dir \((.+)\)$/i) {
      $header->{"wind_dir"}->{"index"} = $i;
      $header->{"wind_dir"}->{"unit"} = $1;
    }
    # Check for a header part that contains the temperature.
    elsif ($data[$i] =~ /10\-m avg temp \(deg (.)\)$/i) {
      $header->{"temp"}->{"index"} = $i;
      $header->{"temp"}->{"unit"} = uc($1);
    }
    # Check for a header part that contains the precip.
    elsif ($data[$i] =~ /^total hourly precip(itation)? \((.+)\)$/i) {
      $header->{"precip"}->{"index"} = $i;
      $header->{"precip"}->{"unit"} = lc($2);
      $header->{"precip"}->{"unit"} =~ s/inches/in/;
    }
    # Check for a header part that contains the pressure.
    elsif ($data[$i] =~ /^(10\-m avg )?barometric pressure \((.+)\)$/i) {
      $header->{"press"}->{"index"} = $i;
      $header->{"press"}->{"unit"} = lc($2);
      $header->{"press"}->{"unit"} =~ s/inches hg/inHg/;
      $header->{"press"}->{"unit"} =~ s/millibars?/mb/;
    }
    # Check for a header part that contains the relative humidity.
    elsif ($data[$i] =~ /^10\-m avg relative humidity \((.+)\)$/i) {
      $header->{"rh"}->{"index"} = $i;
      $header->{"rh"}->{"unit"} = lc($1);
      $header->{"rh"}->{"unit"} =~ s/pct/\%/;
    }
    # Handle all other unknown header types.
    else {
      printf("Don't know how to handle header: %s\n",$data[$i]);
      exit(1);
    }
  }

  return $header;
}

##-------------------------------------------------------------------------
# @signature void parse_raw_file(String file)
# <p>Process the file by parsing the raw data and converting it into the
# QCF format.</p>
#
# @input $file The full path to the file to be parsed.
##-------------------------------------------------------------------------
sub parse_raw_file {
    my ($self,$file) = @_;

    printf("Processing file: %s...\n",$file);

    open(my $FILE,$file) or die("Can't read $file\n");

    # Determine the station id from the file name.
    $file =~ /([^\/]+)\.txt/i;
    my $id = $1;
    $id =~ s/contd//;
    my $station = Station::Station->new($id,$self->{"NETWORK"});

    # Determine the station name from the first header line.
    <$FILE> =~ /Data from GBUAPCD\s+(.+)$/;
    $station->setStationName(trim($1));

    # Determine the station location from the second header line.
    my $location = <$FILE>;
    $location =~ /Latitude:\s+(\-?\d+\.\d+)/i;
    my $lat_fmt = $1 < 0 ? "-" : "";
    while (length($lat_fmt) < length($1)) { $lat_fmt .= "D"; }
    $station->setLatitude($1,$lat_fmt);

    $location =~ /Longitude:\s+(\-?\d+\.\d+)/i;
    my $lon_fmt = $1 < 0 ? "-" : "";
    while (length($lon_fmt) < length($1)) { $lon_fmt .= "D"; }
    $station->setLongitude($1,$lon_fmt);

    $location =~ /Elevation:\s+(\-?\d+)(.+)$/i;
    if (defined($2) && trim($2) eq "'") {
      $station->setElevation($1,"ft");
    } elsif (defined($2) && trim($2) eq "meters") {
      $station->setElevation($1,"m");
    } elsif (defined($2)) {
      die("Unknown elevation units: $2\n");
    }

    $station->setLatLongAccuracy(4);
    $station->setReportingFrequency("hourly");
    $station->setStateCode("CA");
    $station->setNetworkIdNumber(99);
    $station->setPlatformIdNumber(374);

    $self->{"stations"}->addStation($station);

    # This line should be empty
    my $line = <$FILE>;

    # This should be Fields:
    if (<$FILE> !~ /^Fields:\s*$/) {
      die("Fields header line not in expected location in $file\n");
    }

    # Determine the index mapping for measurements.
    $line = <$FILE>;
    my $header = $self->parse_header($line);

    # This line should be empty.
    $line = <$FILE>;

    # The rest of the files should be data.
    $line = <$FILE>;
    while (defined($line)) {
      chomp($line);
      my @data = split(/,/,$line);

      my $record = Surface::QCFSurfaceRecord->new($self->{"WARN"},$station);

      # Parse out the date and time for the record.
      my $date = sprintf("%02d/%02d/%04d",split(/\//,$data[$header->{"date"}->{"index"}]));
      my $time = sprintf("%04d",$data[$header->{"time"}->{"index"}]);

      $record->setReadingTime($date,"MM/DD/YYYY",$time,"HHMM",8);

      # Set the temperature if it was defined in the header.
      if (defined($header->{"temp"}) && $data[$header->{"temp"}->{"index"}] != 999) {
         $record->setTemperature($data[$header->{"temp"}->{"index"}],$header->{"temp"}->{"unit"});
      }
      # Set the relative humidity if it was defined in the header.
      if (defined($header->{"rh"}) && $data[$header->{"rh"}->{"index"}] != 999) {
         if ($header->{"rh"}->{"unit"} eq "%") {
           $record->setRelativeHumidity($data[$header->{"rh"}->{"index"}]);
         } else {
           printf("Unknown relative humidity unit: %s\n",$header->{"rh"}->{"unit"});
           exit(1);
         }
      }
      # Set the wind speed if it was defined in the header.
      if (defined($header->{"wind_spd"}) && $data[$header->{"wind_spd"}->{"index"}] != 999) {
         $record->setWindSpeed($data[$header->{"wind_spd"}->{"index"}],$header->{"wind_spd"}->{"unit"});
      }
      # Set the wind direction if it was defined in the header.
      if (defined($header->{"wind_dir"}) && $data[$header->{"wind_dir"}->{"index"}] != 999) {
        if ($header->{"wind_dir"}->{"unit"} eq "deg") {
          $record->setWindDirection($data[$header->{"wind_dir"}->{"index"}]);
        } else {
          printf("Unknown wind direction unit: %s\n",$header->{"wind_dir"}->{"unit"});
          exit(1);
        }
      }
      # Set the pressure if it was defined in the header.
      if (defined($header->{"press"}) && $data[$header->{"press"}->{"index"}] != 999) {
        $record->setPressure($data[$header->{"press"}->{"index"}],$header->{"press"}->{"unit"});
      }
      # Set the precip if it was defined in the header.
      if (defined($header->{"precip"}) && $data[$header->{"precip"}->{"index"}] != 999) {
        $record->setPrecip($data[$header->{"precip"}->{"index"}],$header->{"precip"}->{"unit"});
      }

      if ($self->{"PROJECT"} eq "T-REX") {
          $self->update_for_TREX($record);
      }

      $self->{"records"}->addRecord($record);

      $line = <$FILE>;
    }

    close($FILE);
}

##-------------------------------------------------------------------------
# @signature void read_raw_files()
# <p>Read in the list of raw data files in the raw data directory and 
# parse them into the QCF format.</p>
##-------------------------------------------------------------------------
sub read_raw_files {
    my ($self) = @_;
    
    opendir(my $RAWDIR,$self->{"RAW_DIR"}) or die("Unable to read raw directory: ".
						  $self->{"RAW_DIR"}."\n");
    my @files = sort(grep(/\.txt$/i,readdir($RAWDIR)));
    closedir($RAWDIR);

    foreach my $file (@files) {
	$self->parse_raw_file(sprintf("%s/%s",$self->{"RAW_DIR"},$file));
    }
}

##-------------------------------------------------------------------------
# @signature String trim(String line)
# <p>Remove the leading and trailing whitespace on a string.</p>
#
# @input $line The data line to be trimmed.
# @output $line The trimmed data line.
##-------------------------------------------------------------------------
sub trim {
  my ($line) = @_;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  return $line;
}

##-------------------------------------------------------------------------
# @signature void update_for_TREX(QCFSurfaceRecord record)
# <p>Update the specified record for changes that only apply during the
# T-REX project.</p>
#
# @input $record The record to be updated.
##-------------------------------------------------------------------------
sub update_for_TREX {
    my ($self,$record) = @_;

    if ($record->getStationId() eq "OLANCHA3" && $record->getActualDate() eq "2006/03/31" &&
        $record->getActualTime() eq "19:00") {
       $record->setPressureFlag($BAD_FLAG);
    }
}

