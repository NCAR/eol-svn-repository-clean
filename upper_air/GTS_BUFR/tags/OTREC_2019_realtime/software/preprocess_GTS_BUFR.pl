#! /usr/bin/perl -w

#--------------------------------------------------------------------------------
# preprocess_GTS_BUFR.pl
#
# 11 July 2019 - LEC
# WARNING: This code has been slightly modified from the non-realtime processing
# software. The only change was instead of expecting *.bufr raw input files,
# this software now expects *.bfr raw input files. Only a file extension change. 
#
#
# The Perl script runs the bufr_dump executable to convert the GTS BUFR "raw" data
# into an ASCII format. This generates very large files that are not very human readable.
# This script then processed those output files to strip extra, unused and blank lines, etc. 
# The output files from this software can then be processed into the NCAR EOL ESC format
# by another piece of conversion software. This script only pre-processing of the 
# raw, binary GTS Bufr data into a more readable form of ASCII.
#
# This s/w will also divide input files that contain multiple soundings into 
# one sounding per output file. Soundings are divided by processing the ASCII files 
# generated by the bufr_dump executable. 
#
# Beware that there are multiple levels of debug that can be executed via
# the "$debug" variables. The "$debug2" variable will cause all stripped
# lines to be written to a "*skiplines" output file. One "skiplines" debug
# file will be created for each input file processed. The "skiplines" files
# can be used to verify if any unexpected lines were encountered. 
# Use linux cat/sort/uniq commands on the skiplines files to see what lines
# were skipped and not written to the preproc output files. 
#
# Execute: 
#    preprocess_GTS_BUFR.pl <raw_GTS_BUFR_dir> <ascii_output_dir> <preproc_output_dir>
#
# Examples: 
#    preprocess_GTS_BUFR.pl ../raw_gts_bufr_data/new_zealand ../output_ascii_data ../output_preproc_data
#
#    preprocess_GTS_BUFR.pl ../test_raw_data ../output_ascii_data ../output_preproc_data
#
#    preprocess_GTS_BUFR.pl ../test/test_zero_files/raw ../test/test_zero_files/output_ascii ../test/test_zero_files/output_prepro
#
# Input: 
#    <raw_GTS_BUFR_dir> - directory where Raw (binary) GTS BUFR sounding data files are located
#    <ascii_output_dir> - directory where ASCII created by bufr_dump executable are output
#    <preproc_output_dir> - directory where "final" pre-processed, ASCII output will be placed
#
# Output: 
#    <ascii_output_dir>/*.asc - Output generated by bufr_dump which is called by this s/w.
#
#    <preproc_output_dir>/*.preproc - Output generated by this s/w. These output files have
#                                     had blank, extraneous and other lines removed. This 
#                                     significantly reduces the size of the ASCII text to
#                                     be converted to NCAR EOL ESC format.
#
#    <preproc_output_dir>/*.preproc.skiplines - Output generated by this s/w but only if
#                                               the $debug2 flag is set to one. These file
#                                               only contain all the skipped/stripped lines
#                                               removed from the *.asc files.  These files
#                                               can be examined to determine what lines were
#                                               stripped. WARNING: This doubles the number of
#                                               output files and the space required to run.
#
# Notes and Assumptions:
#
# 1. The user should search for HARDCODED, ASSUMPTIONS, BEWARE, WARNING, and ERROR in this code. 
#    The user should also search for "exit" in this code so that they know all the possible
#    places/reasons why this code will stop executing.
#
# 2. ASSUMPTION: That the raw data are in expected GTS BUFR format (binary)
#
# 3. ASSUMPTION: That the bufr_dump executable is in same dir as this script. Note that bufr_dump
#    requires the libeccodes.so libraries to execute. Those libraries must be located
#    in the ../lib/ directory.  A copy of that library should be found with this software in subversion. 
#    Note that the bufr_dump executable was supplied "as is" and is used as a "black box" by this s/w.
#    Here are some additional notes on the ebufr_dump binary:
#    S. Loehrer downloaded a complete set of ebufr_dump s/w plus a lot
#    of extraneous elements from ECCODES.com. How did he or did he rebuild it- Unknown.
#    A tar file of all that he downloaded can be found in subversion with this
#    preprocessing software.
#
# 4. ASSUMPTION IMPORTANT LIBRARY INFO: bufr_dump binary expects the libeccodes.so file to be 
#    located in a directory named "lib" one directory level above where bufr_dump is being executed.
#    That directory may need to be created for this software to work. 
#
# 5. Found that some soundings had "ERROR" &/or "ERROR: unreadable message"
#    in the data. Found on the bufrHeaderCentre line which is believed
#    to be the beginning of a new sounding. This s/w still generates
#    the sounding (if there are any data recs) to output. If there are
#    no data records an empty file (.preproc) files is generated so
#    that the user can verify that the input bufr file was processed.
#    An "ERROR" message is issued to the user, when these specific
#    messages are found in the *.asc files.
#
# 6. Since it's impossible to know what could be in a file (including junk),
#    a random limit of 10 output files have been set. If a single input file
#    generates 10 output sounding files, the s/w will exit. This is to prevent
#    a run away process. Not seen in data samples but anything could be possible.
#    Search for the work "random" to find where code sets this limit. 
#
# 7. REALTIME MOD - That incoming raw bufr data files have suffix of .bfr.
#
# Created: L. Cully Sept 2018
#
# Updates:
# July 2019 - Slight mods for REALTIME processing. Expect incoming BUFR files
#    to have suffix of "bfr".
#
#--------------------------------------------------------------------------------
use strict;

my $debug  = 0; # BEWARE: Generates a lot of debug!
my $debug2 = 1; # BEWARE: Causes all skipped lines to be written to *_skiplines.txt output files

my $OUTFILE_SKIP;
my $SkippedRec = 0;

my $TotalRecProc = 0;
my $OutputRec = 0;

&main();

#--------------------------------------------------------------
# void main()
# Run the scripts to prepare the raw binary GTS BUFR data into a 
# form that can be processed by the sounding conversion s/w.
#--------------------------------------------------------------
sub main 
   {
   printf "\npreprocess_GTS_BUFR.pl began on ";print scalar localtime;printf "\n";

   if ($debug) {print "Enter Main:: length ARGV = $#ARGV,  ARGV() = @ARGV\n";}

   if ($#ARGV < 2)
      { 
      print "Incorrect number of command line arguments!\n ARGV = @ARGV\n";
      print "Usage: preprocess_GTS_BUFR.pl <raw_GTS_BUFR_dir> <ascii_output_dir> <preproc_output_dir>\n";
      exit(1);
      }

   #--------------------------------------------------------------------------------
   # This dir contains the Raw (binary) data in GTS BUFR format to be converted by
   # the bufr_dump executable.
   # Examples:
   #   my $INPUT_GTS_BUFR_DIR = "../raw_data/new_zealand";
   #   my $INPUT_GTS_BUFR_DIR = "../test_raw_data";
   #--------------------------------------------------------------------------------
   my $INPUT_GTS_BUFR_DIR  = $ARGV[0];
   if ($debug) {print "INPUT_GTS_BUFR_DIR = $INPUT_GTS_BUFR_DIR \n";}

   #--------------------------------------------------------------------------------
   # ASCII output from the bufr_dump executable. These ASCII output files are
   # then pre-processed to be more manageable and human readable into *.preproc*
   # output files. Example:  my $OUTPUT_GTS_ASCII_DIR = "../output_ascii_data";
   #--------------------------------------------------------------------------------
   my $OUTPUT_GTS_ASCII_DIR  = $ARGV[1];
   if ($debug) {print "OUTPUT_GTS_ASCII_DIR = $OUTPUT_GTS_ASCII_DIR \n";}

   #-------------------------------------------------------------------------------------
   # Pre-process ASCII output to be more manageable and human readable.
   # Note that the ASCII output from ebufr_dump can contain well over 1 million lines
   # many may be nearly blank and unnecessary for final conversion to NCAR EOL ESC
   # format. This also makes the ASCII data in a human-friendly format for data checking.
   # This final pre-proc step is done with a single sed command below.
   # Example: my $OUTPUT_PREPROC_DIR = "../output_preproc_data";
   #-------------------------------------------------------------------------------------
   my $OUTPUT_PREPROC_DIR = $ARGV[2];
   if ($debug) {print "OUTPUT_PREPROC_DIR = $OUTPUT_PREPROC_DIR \n";}

   #----------------------------------------------------------------
   # Read in the list of files to process from BUFR to ASCII.
   # Changed for realtime processing from *.bfr.
   #----------------------------------------------------------------
   printf "Opening INPUT_GTS_BUFR_DIR:: $INPUT_GTS_BUFR_DIR\n";
   opendir(my $INPUT_DIR, $INPUT_GTS_BUFR_DIR) or die("Cannot open $INPUT_GTS_BUFR_DIR\n");
   my @files = grep(/\.bfr$/,readdir($INPUT_DIR));
   closedir($INPUT_DIR);

   my $soundingCt = 1;

   #----------------------------------------------------------------
   # Process every BUFR file (*.bfr) in the input directory.
   # Changed for realtime processing from *.bfr.
   #----------------------------------------------------------------
   foreach my $file (sort(@files)) 
       {
       #----------------------------------------------------------------
       # Form and execute system command to convert from BUFR to ASCII
       # That is, run bufr_dump executable on raw BUFR files. 
       #----------------------------------------------------------------
       if ($debug) {print "-----------------------------\n";}
       printf "\nprocessing GTS BUFR file: $file \n";

       my @name_parts = split (/.bfr/, $file);    # HARDCODED
       if ($debug) {print "name_parts = @name_parts\n";}

       #----------------------------------------------------------------
       # gts_ascii_file   - Output from bufr_dump()
       # gts_preproc_file - Final output from this preprocessing program
       #    which is input to sounding conversion program. 
       #    There can be more than one sounding per input file so add
       #    a sounding number to preproc output file name.
       #----------------------------------------------------------------
       my $gts_ascii_file = sprintf("%s/%s.asc", $OUTPUT_GTS_ASCII_DIR, $name_parts[0]);    # HARDCODED
       my $gts_preproc_file = sprintf("%s/%s_%d.preproc", $OUTPUT_PREPROC_DIR, $name_parts[0], $soundingCt);  # HARDCODED

       if ($debug) {print "gts_ascii_file = $gts_ascii_file\n";}
       if ($debug) {print "gts_preproc_file = $gts_preproc_file\n";}

       #----------------------------------------------------------------
       # Form the bufr to ascii conversion command and execute.
       #----------------------------------------------------------------
       my $cmdbufrdump = sprintf("./bufr_dump %s/%s > %s", $INPUT_GTS_BUFR_DIR, $file, $gts_ascii_file ); # HARDCODED
       print "Execute system cmd:: $cmdbufrdump\n";

       system ($cmdbufrdump); # convert BUFR to ASCII

       #----------------------------------------------------------------------------------------
       # Form and execute system command to pre-process initial ASCII
       # output from the bufr_dump executable. Tried following sed commands but 
       # experience issued (possibly limits to memory) for commands, so these
       # were not used in this code. Sed did not work consistently.
       #
       # sed 's/^ *//; s/ *$//; /^ *$/d; /^\[/d; /^\]/d' file.txt > output.txt
       #
       #    `s/^ *//`  => left trim whitespace, may have other chars
       #    `s/ *$//`  => right trim whitespace, may have other chars
       #    '/^ *$/d'  => Delete all lines which are empty or which contain just blank spaces
       #    '/^\[/d'   => remove lines beginning with "["
       #    '/^\]/d'   => remove lines beginning with "]" (also removes lines with only "],"
       #
       # Note must "backslash" all dollar signs to prevent Perl from interpreting as a variable.
       # WAS  my $sedcmd = "sed 's/^ *//; s/ *\$//; /^ *\$/d; /^\[/d; /^\]/d'";
       #----------------------------------------------------------------------------------------
       # my $sedcmd = "sed 's/^ *//; s/ *\$//; /^ *\$/d;'";
       # my $cmdpreproc = sprintf("%s %s > %s", $sedcmd , $gts_ascii_file , $gts_preproc_file );
       # if ($debug) {print "Execute system cmd:: $cmdpreproc\n";}
       # system ($cmdpreproc);
       #----------------------------------------------------------------------------------------

       #-------------------------------------------------------------
       # Process lines in file to combo key/value/units onto one line
       # and to strip lines with only brackets. 
       #-------------------------------------------------------------
       open(my $FILE_DUMP,"<", $gts_ascii_file) or die("Can't open file for reading: ".$gts_ascii_file); #from bufr_dump
       open(my $OUTFILE,">", $gts_preproc_file) or die("Can't open file for writing: ".$gts_preproc_file); #"cleaned" output files

       #--------------------------------------------------------------
       # If requested, open a "debug" file just for skipped records.
       # These files go into the same dir as the "final" preprocessed 
       # files. Note that if more than one sounding in an input file,
       # then all skipped lines are put to the same (i.e., 
       # "_1.preproc.skiplines") debug output file.
       #--------------------------------------------------------------
       if ($debug2) 
          {
          my $skiplines_file = sprintf("%s.skiplines", $gts_preproc_file);  # HARDCODED
          
          print "Opening output file to save ALL SKIPPED input line into single output file = $skiplines_file\n";
          open($OUTFILE_SKIP,">", $skiplines_file) or die("Can't open file for writing: ".$skiplines_file);
          }

       my @lines = <$FILE_DUMP>; 
       my $number_lines_in_file = $#lines+1;

       #------------------------------------------------------------
       # ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       #  $atime,$mtime,$ctime,$blksize,$blocks) = stat($filename);
       #------------------------------------------------------------
       # Stat array results::
       #  0 dev device number of filesystem
       #  1 ino inode number
       #  2 mode file mode (type and permissions)
       #  3 nlink number of (hard) links to the file
       #  4 uid numeric user ID of file's owner
       #  5 gid numeric group ID of file's owner
       #  6 rdev the device identifier (special files only)
       #  7 size total size of file, in bytes
       #  8 atime last access time in seconds since the epoch
       #  9 mtime last modify time in seconds since the epoch
       # 10 ctime inode change time in seconds since the epoch (*)
       # 11 blksize preferred block size for file system I/O
       # 12 blocks actual number of blocks allocated
       #------------------------------------------------------------
       my @file_info = stat $FILE_DUMP;
       if ($debug) { print "file_info:: @file_info\n"; print "number_lines_in_file:: $number_lines_in_file \n"; print "File size = $file_info[7]\n"; }
       close($FILE_DUMP);

       $TotalRecProc = 0;
       $SkippedRec = 0;
       $OutputRec = 0;

       my $out_string = "";
       my $letter = '';

       # -----------------------
       # -----------------------
       # Loop through file lines
       # -----------------------
       # -----------------------
       foreach my $line (@lines)
         {
         $TotalRecProc++;

         chomp ($line); #remove return \n
         if ($debug) {print "Orig Line: xxx $line xxx\n";}

         # -------------------------------------------------
         # If line starts with begin/end bracket or if blank
         # skip it. Helpful at end of file. Else write the
         # line to the output file. Also remove extra 
         # whitespace in the line.
         # -------------------------------------------------
         $line =~ s/^\s+|\s+$//g; #Strip white space from both ends of string

         if ($line =~ /^\s*$/) 
            {
            if ($debug) {print "SKIP Blank Line: $line\n";}
            if ($debug2) { printf ($OUTFILE_SKIP $line."\n");} # Save skipped lines for debug2 

            $SkippedRec++;     
            next; 
            }

         # Remove odd lines with only brackets, single commas, first message line, etc.
         if ($line eq "[" || $line eq "]" || $line eq "];"|| $line eq "]," ||
             $line eq "," || $line eq "\{ \"messages\" \: \[" || $line eq "]}"  ) 
            { 
            if ($debug) {print "SKIP Bracket and Message Lines: $line\n";} 
            if ($debug2) { printf ($OUTFILE_SKIP $line."\n");} # Save skipped lines for debug2 

            $SkippedRec++;     
            next; 
            }

         # ---------------------------------------------------------------
         # ASSUMPTIONS:
         # If found another sounding in the ascii dumped file,
         # then close current output file and open another so
         # that only one sounding per output file. A new sounding
         # appears to start with the following line:
         #    { "key" : "bufrHeaderCentre", "value" : 69 },
         # 
         # Soundings appear to end with the following line:
         #    { "key" : "operator", "value" : "Increasing pressure" }
         #
         # Index() returns the position of the first occurrence of 
         # a $substr in $str, or -1 if the substring is not found.
         #
         # if (index($str, $substr)!= -1){print "$str contains $substr\n";} 
         #
         # WARNING:
         # Found that some soundings had "ERROR" &/or "ERROR: unradable message"
         # in the data. Found on the bufrHeaderCentre line which is believe
         # to be the beginning of a new sounding. This s/w still generates
         # the sounding (if there are any data recs) to output. If there are
         # no data records an empty file (.preproc) files is generated so
         # that the user can verify that the input bufr file was processed. 
         # ** Have seen "junk" *asc files that do not have a bufrHeaderCentre
         # line but start with '{ "messages" : [' line followed with error lines.
         # -----------------------------------------------------------------------
         my $soundingTop = "bufrHeaderCentre";  # HARDCODED
         my $err1 = "ERROR";                    # HARDCODED
         my $err2 = "unreadable message";       # HARDCODED

         if ($debug) {print "soundingTop:: xxx $soundingTop xxx. line:: $line\n";}

         if (( index($line, $err1) != -1) || (index($line, $err2) != -1))  # Found Error in line
            {
            print "ERROR: Error or unreadable message found. Search input file for ERROR! Possible Bad Output File!\n";
            print "ERROR line: xxx $line xxx\n";

            }


         if ( index($line, $soundingTop) != -1)  # Found first record in a sounding
            {
            if ( $soundingCt != 1 ) # Not first sounding in file
               {
               # Close current output file and open another output file. Possible Multiple sounding in file.
               close ($OUTFILE);
       
               $gts_preproc_file = sprintf("%s/%s_%d.preproc", $OUTPUT_PREPROC_DIR, $name_parts[0], $soundingCt); # HARDCODED

               print "MATCH:: Found another sounding in this file! Opening next Sounding File: gts_preproc_file = $gts_preproc_file\n";
               open($OUTFILE,">", $gts_preproc_file) or die("Can't open file for writing: ".$gts_preproc_file); 
               }
            else
               {
               print "FOUND FIRST Sounding in file. Input Line = $soundingTop\n";
               }

            if ($soundingCt > 10) {print "ERROR: Exiting due to >10 soundings in a single input file! exit(1)\n"; } # HARDCODED - random limit of 10 set to prevent run away number of soundings in a file

            $soundingCt++;
            }

         # -------------------------------------------------------------------------
         # Put "key", "value", and "units" to single output line.
         # if( $letter =~ /\d+/ ){
         #     print "$letter is a number\n";
         #     }
         #
         #     if (/\D/)            { print "has nondigits\n" }
         #     if (/^\d+$/)         { print "is a whole number\n" }
         #     if (/^-?\d+$/)       { print "is an integer\n" }
         #     if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
         #     if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
         #     if (/^-?(?:\d+(?:\.\d*)?&\.\d+)$/) { print "is a decimal number\n" }
         #     if (/^([+-]?)(?=\d&\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
         #                          { print "a C float\n" }
         #
         # HARDCODED in next section below.
         # --------------------------------------------------------------------------
         $letter = substr($line, 0, 1); # first char in line
         if ($debug) {print "First Letter:: letter: xxx $letter xxx\n";}

         if ($letter eq "{" || $letter eq "\"" )    # Beginning or part of parm set
            {
            $out_string = $out_string." ".$line;
            if ($debug) {print "-------\nForm Output String:: out_string: xxx $out_string xxx\n";}

            # Catch odd error generated by bufr_dump. Write line to output file Warn user.
            if (index($line, "ERROR") != -1)
               {
               printf ($OUTFILE $out_string."\n");
               $OutputRec++;

               print "WARNING:  Error line PRINTED TO OUTPUT:: out_string: xxx $out_string xxx\n";
               $out_string = ""; # Blank out for next parm set
               } # error found in input asc file
            }
         elsif ($letter =~ /\d+/ ) # Digits only found with unexpanded parms. Add to line.
            { 
            $out_string = $out_string." ".$line;
            if ($debug){print "FOUND number and not char $letter\n";}
            }
         elsif ($letter eq "}")                  # End of parm set -- was "},"
            {
            $out_string = $out_string." ".$line;
            printf ($OUTFILE $out_string."\n");   # Write to output file
            $OutputRec++;
            $out_string = ""; # Blank out for next parm set

            if ($debug) {print "Hit End for Output String. Write to output:: out_string: xxx $out_string xxx\n------\n";}
            }
         else
            {
            printf ($OUTFILE $out_string."\n");
            $OutputRec++;

            print "WARNING:: UNKNOWN Line Type at $TotalRecProc. PRINTED TO OUTPUT:: out_string: xxx $out_string xxx\n";
            $out_string = ""; # Blank out for next parm set
            }

         } # end foreach all lines in the file

         close ($OUTFILE);
         if ($debug2) {close ($OUTFILE_SKIP);}


         print "Total Lines Processed from Input File: $TotalRecProc\n";

         my $percent = ($SkippedRec/$TotalRecProc)*100.0;
         my $result = sprintf("%s %d ( %.2f %s)\n", "Total Lines Skipped:", $SkippedRec, $percent, "\%");
         print $result;

         $percent = ($OutputRec/$TotalRecProc)*100.0;
         $result = sprintf("%s %d ( %.2f %s)\n", "Total (input compressed down to) Lines in Output:", $OutputRec, $percent, "\%");
         print $result;


         #-------------------------------------------------------------------
         # Determine if bufr_dump ASCII file has multiple soundings included.
         # Backtick marks are used around a command to capture the result of
         # the output from line command. Assumes Linux grep and wc cmds viable
         # on OS. The backticks can be hard to see in the code depending
         # on your editor. This section added as a double check on expected
         # versus actual number of soundings found in the input data. 
         # Note that if you do a Perl system command that does *not*
         # return the result from the issued command. It returns a status.
         #
         # If file has more than one sounding, then this file
         # must be split and then each sounding processed separately.
         #-------------------------------------------------------------------
         my $system_cmd_return = `grep bufrHeaderCentre $gts_ascii_file | wc -l`; #HARDCODED backticks in cmd
         chomp ($system_cmd_return);  # Cut off \n at end of returned value

         if ($debug) {print "Execute GREP cmd:: xxx grep bufrHeaderCentre  $gts_ascii_file | wc -l xxx\n";}
         if ($debug) {print "Output from GREP system cmd:: xxx $system_cmd_return xxx\n";}

         $soundingCt--; # Decrement down to actual sounding count found

         if ($soundingCt >= 1)
            {
            print "Expected number of soundings in input file (via Grep) = $system_cmd_return \n";
            print "Actual number of soundings found in input file = $soundingCt \n";

            if ( $system_cmd_return != $soundingCt) 
               { print "WARNING: Expected versus Actual number soundings found in input file ( $gts_ascii_file ) DO NOT MATCH!\n";}
            }
        elsif ($soundingCt == 0)
            { print "WARNING: No Soundings found ($soundingCt) in input file!\n"; }
        else
            { print "Found $soundingCt soundings in input file.\n"; }

        $soundingCt = 1;   # Reset for next input file. Expect at least 1 per file

       } # end foreach file in the input directory

    printf "\npreprocess_GTS_BUFR.pl ended on ";print scalar localtime;printf "\n";
    }
