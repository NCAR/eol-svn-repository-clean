#! /usr/bin/perl -w
#
##Module-------------------------------------------------------------------------
# <p>The BAE146netCDF_to_ESC.pl script is used for converting NetCDF
# sounding data files to the EOL Sounding Composite (ESC) format.
#
#
# @author Linda Echo-Hawk 2010-06-02
# @version VOCALS_2008 Adapted from the ARM-CART netCDF converter.
#          - BEWARE: This code expects the raw data to be in 
#            subdirectories by flight (e.g., raw_data/B412_081031/*.nc)
#          - NetCDF variables are one-dimensional with respect to time.
#          - Reads in a separate text file for the header line
#            "Comments" (docs/Header_Info.txt) by sounding number
#            and stores this in @headerComments.
#          - The HeaderInfo.txt file is generated by running the
#            FindHeaderComment.pl script in the raw_data directory.
#            See FindHeaderComment.pl for usage and example notes.
#            BEWARE:  This had to be manually corrected for files
#            that were not processed.  
#          - Header lat/lon/alt values are from the last data record.
#          - Release time was taken from the Sounding Description 
#            global variable.  The "base_time" var from file was not
#            used except to confirm that these two times matched.
#          - Search for "HARD-CODED" to find other values that may
#            need to be changed for other projects.
#
#
##Module-------------------------------------------------------------------------
package BAE146_NetCDF_Converter;
use strict 'vars';

#-------------------------------------------------------------------------------
# Note that a backslash before a variable indicates a reference to that
# variable.
#-------------------------------------------------------------------------------
# Include NetCDF module in this code. Note that the NetCDF module is NOT
# installed on every EOL machine. 'use' is a compile time directive. It is
# shorthand for the following:
#BEGIN {
#       require YourModule;
#       YourModule->import(LIST);
#      } 
# By wrapping the require and import in an eval, we can let the user know
# where to run the code and exit gracefully.
#
#use NetCDF;	# does NOT die gracefully when run on a machine where
# NetCDF.pm is not installed. So...
BEGIN {
  eval {
    require NetCDF;
    NetCDF->import();
  };

  if ($@) {
    print "\nERROR: This code requires the NetCDF.pm module which is\n".
   	  "apparently not installed on the machine on which you are \n".
	  "attempting to run the code. Please run this code on merlot\n".
	  "or tsunami.\n\n"; 
    exit(1);
  }
}

if (-e "/net/work") {
    use lib "/net/work/lib/perl/Utilities";
    use lib "/net/work/lib/perl/UpperAir";
    use lib "/net/work/lib/perl/Station";
} else {
    use lib "/work/lib/perl/Utilities";
    use lib "/work/lib/perl/UpperAir";
    use lib "/work/lib/perl/Station";
}
use DpgConversions;
use DpgCalculations;  
use DpgDate qw(:DEFAULT);
use NCutils;                               
# to dump the contents of the hash
use Data::Dumper;    
use ClassConstants qw(:DEFAULT);  
use ClassHeader;
use ClassRecord;
use SimpleStationMap;
use Station;
# import module to set up command line options
use Getopt::Long;

# PERL standard module which allows the code to refer to each component of the 
# time by name, i.e. ->year
use Time::gmtime;

# Routines ParseDate and UnixDate are contained within this CPAN module
use Date::Manip;  

my ($WARN);

# -------------------------------------
# too many global variables
# -------------------------------------
# @release = (year,month,day,hour,minute,second)
my @release;
my $flightNumber = "";
my $sondeId = "";
# from a separate text file, e.g., "Good drop."
my @headerComments;
# to match up header comments to each sounding
my $numSounding = 0;

my %global_atts;
                                              

printf "\nBAE146netCDF_to_ESC.pl began on ";print scalar localtime;printf "\n";
&main();
printf "\nBAE146netCDF_to_ESC.pl ended on ";print scalar localtime;printf "\n";


#*********************************************************************

# There are a ton of print statements in this code for debugging and 
# informational purposes.  Turn them on or off and see what you get (-:
sub DEBUG       {return 0; }
sub DEBUGoutput {return 0;}		# debug info for parse_data_rec subroutine
sub DEBUGgetV {return 1;}               # debug info for netCDF subroutine
sub DEBUGFileStats {return 1;}


# I like to define variables FALSE and TRUE and use them rather than one
# and zero in by comparison statements.  I think it is clearer.
sub FALSE       {return 0; }
sub TRUE        {return 1; }

#*********************************************************************



##------------------------------------------------------------------------------
# @signature void main()
# <p>Execute the conversion of the data.</p>
##------------------------------------------------------------------------------
sub main {
    my $converter = BAE146_NetCDF_Converter->new();
    $converter->convert();
}
##------------------------------------------------------------------------------
# @signature void convert()

# <p>Convert all of the raw data and create the output files for the conversion.</p>
##------------------------------------------------------------------------------
sub convert {
	my ($self) = @_;

    mkdir($self->{"OUTPUT_DIR"}) unless (-e $self->{"OUTPUT_DIR"});
    mkdir("../final") unless (-e "../final");

    $self->readRawDataFiles();
    $self->printStationFiles();
}


##------------------------------------------------------------------------------
# @signature BAE146_NetCDF_Converter new()
# <p>Create a new BAE146_NetCDF_Converter instance.</p>
#
# @output $converter The new converter.
##------------------------------------------------------------------------------
sub new {
    my $invocant = shift;
    my $self = {};
    my $class = ref($invocant) || $invocant;
    bless($self,$class);

    $self->{"stations"} = SimpleStationMap->new();

    # ----------------------------------
    # HARD-CODED
    # ----------------------------------
    $self->{"PROJECT"} = "VOCALS_2008";
    $self->{"NETWORK"} = "BAE_146";
    # ----------------------------------
    
	$self->{"FINAL_DIR"} = "../final";
    $self->{"OUTPUT_DIR"} = "../output";
    $self->{"RAW_DIR"} = "../raw_data";    


	$self->{"HEADER_INFO_FILE"} = "../docs/HeaderInfo.txt";

    $self->{"STATION_FILE"} = sprintf("%s/%s_%s_stationCD.out",$self->{"FINAL_DIR"},
                                      $self->clean_for_file_name($self->{"NETWORK"}),
                                      $self->clean_for_file_name($self->{"PROJECT"}));

    $self->{"SUMMARY"} = $self->{"OUTPUT_DIR"}."/station_summary.log";
    $self->{"WARN_LOG"} = $self->{"OUTPUT_DIR"}."/warning.log";

    return $self;
}

##---------------------------------------------------------------------------
# @signature void printStationFiles()
# <p>Generate the stationCD.out file and the station summary log for the 
# stations in the conversion.</p>
##---------------------------------------------------------------------------
sub printStationFiles {
    my ($self) = @_;
    my ($STN, $SUMMARY);

    open($STN, ">".$self->{"STATION_FILE"}) || die("Cannot create the ".$self->{"STATION"}." file\n");
    foreach my $station ($self->{"stations"}->getAllStations()) {
        print($STN $station->toString()) if ($station->getBeginDate !~ /^9+$/);
    }
    close($STN);

    open($SUMMARY, ">".$self->{"SUMMARY"}) || die("Cannot create the ".$self->{"SUMMARY"}." file.\n");
    print($SUMMARY $self->{"stations"}->getStationSummary());
    close($SUMMARY);
}

##------------------------------------------------------------------------------
# @signature void readRawDataFiles()
# <p>Determine all of the raw NetCDF data files that need to be processed
# and then process them.</p>
##------------------------------------------------------------------------------
sub readRawDataFiles {
    my ($self) = @_;

	# Read in the text file to get header comments
	open(my $INFO,$self->{"HEADER_INFO_FILE"}) 
	    or die("Can't open file ".$self->{"HEADER_INFO_FILE"}); 
	@headerComments = <$INFO>;
	close($INFO);                                                                            

    opendir(my $RAW,$self->{"RAW_DIR"}) or die("Can't open raw data directory\n");
    my @flights = grep(/^[^\.]+$/,readdir($RAW));
    closedir($RAW);            

	foreach my $flight (@flights) {
    opendir(my $RAW,$self->{"RAW_DIR"}."/".$flight) 
	          or die("Cannot open raw directory for $flight.\n");
    
    my @files = grep(/\.nc$/,readdir($RAW));

    closedir($RAW);

    open($WARN,">".$self->{"WARN_LOG"}) or die("Can't open warning file.\n");

    foreach my $file (sort(@files)) {
	    printf("\nProcessing: %s ...\n",$file);                                                   
	    $self->readRawFile($file,$flight,$numSounding) if ($file =~ /\.nc$/);
		# print "COUNT: $numSounding\n";
		$numSounding++;
    }
    }
    close($WARN);
}

##---------------------------------------------------------------------
# @signature ClassHeader parseHeader($baselat, $baselon, $basealt)
# <p>Create the header object and set the values.</p>
#
# @input $baselat, $baselon, $basealt - The release location values.
# @output $header The header data in ESC format
##---------------------------------------------------------------------   
sub parseHeader
{
	my ($self) = shift;
	my $baselat = shift;
	my $baselon = shift;
    my $basealt = shift;
	# print "BASELAT: $baselat  BASELON: $baselon  BASEALT: $basealt\n";
	
	# -------------------------------------------------------------
    # Get the header "Comments" line for this sounding
	# -------------------------------------------------------------    
	my $line = $headerComments[$numSounding];
	chomp($line);
	my $comments = (split(/:/,$line))[1];
	$comments = trim($comments);
	print "\tHEADER COMMENT: $comments\n";

    # -------------------------------------------
    # Create the header object and set the values
    # -------------------------------------------
    my $header = ClassHeader->new($self->{"WARN"});

	# --------------------------------------------
	# HARD-CODED
	# --------------------------------------------
	$header->setReleaseDirection("Descending");
    # Set the type of sounding
	$header->setType("FAAM Dropsonde");
	$header->setProject($self->{"PROJECT"});
    # The Id will be the prefix of the output file
	$header->setId("BAE_146");
	# "Release Site Type/Site Id:" header line
	$header->setSite("BAE-146"."/".$flightNumber);

    $header->setLatitude($baselat, $self->buildLatlonFormat($baselat));
	$header->setLongitude($baselon, $self->buildLatlonFormat($baselon));
	$header->setAltitude($basealt, "m");

    my $date = sprintf("%04d, %02d, %02d", $release[0], $release[1], $release[2]);
	my $time = sprintf("%02d:%02d:%02d", $release[3], $release[4], $release[5]);
    $header->setActualRelease($date,"YYYY, MM, DD",$time,"HH:MM:SS",0);
	$header->setNominalRelease($date,"YYYY, MM, DD",$time,"HH:MM:SS",0);

    # --------------------------------------------------
    # Add all non-predefined header lines to the header.
    # --------------------------------------------------
    my $sondeLabel = "Sonde Id/Sonde Type";
	$header->setLine(5, $sondeLabel.":", $sondeId);

	my $commentLabel = "Comments";
	$header->setLine(6, $commentLabel.":", $comments);

    # --------------------------------------------------

	return $header;
}


#---------------------------------------------------------------------
# @signature void parse_data_rec($file, $recdimLen, $var )
# <p>Loop through the data and fill the output hash with values, 
#    then print the ClassRecord objects to the output file.</p>
#
# @input $file (the raw data file)
# @input $recdimLen  (the number of data records)
# @input $var (the variable, e.g., time, temp, wind dir, etc.)
#---------------------------------------------------------------------
sub parse_data_rec
{
	my ($self) = shift;
	my $file = shift;
    my $recdimLen = shift;
    my $var = shift;

	# Fill the output hash with the values
    my %output = ();

    foreach (my $recnum=0; $recnum < $recdimLen; $recnum++) 
	{
		if (&DEBUGoutput) {print "\n\n";}
    	if (&DEBUGoutput) {print "Processing record $recnum\n\n";}
        
  	    # $recnum is the index of all the data for a single time.  
    	# Process this record and the next one.
    	for (my $i = $recnum; $i < $recdimLen && $i <= $recnum+1; $i++) 
		{
			$output{Time}[$i] = getVar("time_offset",$var,$i); #Time offset from base time
	  		$output{Press}[$i] = getVar("pres",$var,$i); #Pressure (hPa)
	  		$output{Temp}[$i] = getVar("tdry",$var,$i);  #Dry Bulb Temp (C)
	  		$output{Dewpt}[$i] = getVar("dp",$var,$i);   #Dewpoint Temp (C)
	 		$output{RH}[$i] = getVar("rh",$var,$i);  #Relative Humidity (%)
	  		$output{Ucmp}[$i] = getVar("u_wind",$var,$i);  #Eastward Wind Component (m/s) 
	  		$output{Vcmp}[$i] = getVar("v_wind",$var,$i);  #Northward Wind Component (m/s)
	  		$output{spd}[$i] = getVar("wspd",$var,$i);  #Wind Speed (m/s)
	  		$output{dir}[$i] = getVar("wdir",$var,$i);  #Wind Direction (deg)	  
	  		$output{Wcmp}[$i] = getVar("dz",$var,$i);  #Ascent Rate (m/s)
	  		$output{Lon}[$i] = getVar("lon",$var,$i);  #East Longitude (deg)	  
	  		$output{Lat}[$i] = getVar("lat",$var,$i);  #North Latitude (deg)	  
	  		$output{Alt}[$i] = getVar("alt",$var,$i);  #altitude (m)	  
	  	} # End for $i loop

        # ------------------------------------------------
		# Create the ClassRecord object for each data 
		# record (recnum) and write it to the output file
		# -----------------------------------------------
		my $record = ClassRecord->new($self->{"WARN"},$file);
	    $record->setTime($output{Time}[$recnum]) 
					if ($output{Time}[$recnum] != -999);
	    $record->setPressure($output{Press}[$recnum],"mb") 
					if ($output{Press}[$recnum] != -999);
	    $record->setTemperature($output{Temp}[$recnum],"C") 
					if ($output{Temp}[$recnum] != -999);    
		$record->setDewPoint($output{Dewpt}[$recnum],"C") 
					if ($output{Dewpt}[$recnum] != -999);
	    $record->setRelativeHumidity($output{RH}[$recnum]) 
					if ($output{RH}[$recnum] != -999);
	    $record->setUWindComponent($output{Ucmp}[$recnum],"m/s") 
					if ($output{Ucmp}[$recnum] != -999);
	    $record->setVWindComponent($output{Vcmp}[$recnum],"m/s") 
					if ($output{Vcmp}[$recnum] != -999);
	    $record->setWindSpeed($output{spd}[$recnum],"m/s") 
					if ($output{spd}[$recnum] != -999);
	    $record->setWindDirection($output{dir}[$recnum]) 
					if ($output{dir}[$recnum] != -999);
	    $record->setAscensionRate($output{Wcmp}[$recnum],"m/s") 
					if ($output{Wcmp}[$recnum] != -999);
		$record->setLatitude($output{Lat}[$recnum],
					$self->buildLatlonFormat($output{Lat}[$recnum])) 
					if ($output{Lat}[$recnum]!= -999) ;
		$record->setLongitude($output{Lon}[$recnum],
					$self->buildLatlonFormat($output{Lon}[$recnum])) 
					if ($output{Lon}[$recnum]!= -999);
		$record->setAltitude($output{Alt}[$recnum],"m") 
					if ($output{Alt}[$recnum]!= -999);

   		print (OUTFILE $record->toString());
		# -----------------------------------------------

	} # End for $recnum loop
}

#---------------------------------------------------------------------
# @signature void getData()
# <p>Read in all the data in the netCDF raw data file.</p>
#
# @input   $ncid  The input file NetCDF identifier
# @input   $recDimName  The name of the record dimension (for VOCALS
#             2008 BAE146 there was one dimension: "time")
# @input   $var  The hash of variable hashes (e.g., wdir, wspd, etc.)
# @input   $recdimLen  The number of data records for this variable
# @input   $numSounding  Which sounding this is (to sync up the 
#             separate file header comments)
# @input   $file  The name of the input raw data file
# @output  %var{$variable}{values} Adds the array values to the
#             hash for each variable
#---------------------------------------------------------------------
sub getData 
{
	my ($self) = shift;
    my $ncid = shift;
    my $recDimName = shift; # the record dimension name is "time"
    my $var = shift;
    my $recdimLen = shift;	# the number of data records
    my $numSounding = shift;
	my $file = shift;
	
	my $basetime;

	my $variable;
    foreach $variable (&getFields) 
	{
        #---------------------------------------------------- 
        # Make sure that the variable the user has requested 
        # in getFields actually exists in the data.
        #----------------------------------------------------
		if (!defined($var->{$variable})) 
	 	{
            print "WARNING: Unknown variable $variable requested by user";
            print " in code at getFields declaration.\n";
            exit(1);
        }
    }
    # Loop over each data record in the netCDF file and read in the data
    foreach (my $record=0; $record < $recdimLen; $record++) 
	{
        if (&DEBUG) {print "Reading in data for record $record $recDimName\n";}

		# For each variable, get the data for this record 
        foreach $variable (&getFields) 
		{
            # if (&DEBUG) {print "Reading in data for variable $variable\n";}
            my @values = ();
            #-------------------------------------------------------------------
			# For BAE data, variables are 1-dimensional with respect to time
            # Example:  float time_offset(time) is a 1-d variable
            #           base_time is a 0-d variable
            #           float pres(launch, altitude) is a 2-d var (from Ron Brown)
            #-------------------------------------------------------------------
            # Note that varget saves the data to the first index of @values.  
			# It appears to save the data point as a float, so information on 
			# significant digits is lost, and we get numbers like 38.4943313598633
            #-------------------------------------------------------------------
			# @start: starting point for data transfer
			# @count: length of data points along each dimension for data transfer
			# These values are more critical for >1-dimensional variables.
			# See RonBrown_netCDF_Converter.pl for example of 2-d variables.
            #-------------------------------------------------------------------
            if ($var->{$variable}{ndims} == 1 ) 
			{
                my @start = ($record);
                my @counts = (1);
                if (NetCDF::varget($ncid,$var->{$variable}{varid},\@start,
                      \@counts, \@values) == -1) 
				{
					die "Can't get data for variable $variable:$!\n";
                }
                $var->{$variable}{values}[$record] = $values[0];
            }
			# the variable base_time has zero dimensions
			# we don't want to read it in for every record, just once is enough
			elsif ($var->{$variable}{ndims} == 0)
			{
				# there is only one data value in base_time
				if ($record == 0)
				{
					# print "Record # $record\n";
					my @start = ($record);
                	my @counts = (1);
					my @value;
                	if (NetCDF::varget($ncid,$var->{$variable}{varid},\@start,
                    	  \@counts, \@values) == -1) 
					{
						die "Can't get data for variable $variable:$!\n";     
					}
					foreach my $val (@values)
					{
				    	# print "$val\n";
						$basetime = $val;
					}
					# print "base_time = $basetime\n";
				}
			}
			           
            # Otherwise, warn the user that we don't know how to read in the
            # variable.
            #-------------------------------------------------------------------
            else 
			{
                print "ERROR: Don't know how to read in variable: $variable(";
                foreach my $dim ( 0 .. $var->{$variable}{ndims}-1) {
                    my $dimname = $var->{$variable}{dimname}[$dim];
                  print "$var->{$variable}{dimname}[$dim]=$var->{$variable}{$dimname} ";
                }
                print ")\n";
            }
        } # End foreach $variable
    } # End foreach $record
	# print Dumper($var);


	# -------------------------------------------------------------
    # Determine release time/date from file's "base_time" variable
	# -------------------------------------------------------------
    # print "base_time = $basetime\n";
	# base_time data value: base_time = 1244935620 
	my ($d, $t) = getDateFromSeconds($basetime);
	# print "\tFROM getDateFromSeconds: actual date = $d  time = $t\n";
	# FROM getDateFromSeconds: nominal date = 2009/06/14  time = 00:00:00
	my ($btYear, $btMonth, $btDay) = split(/\//, $d);
	my ($btHour, $btMinute, $btSecond) = split(/:/, $t);

	# ----------------------------------------------------------------------
    # Compare file's base_time value with the Sounding Description date/time
	# ----------------------------------------------------------------------
	if (($release[0] != $btYear) || ($release[1] != $btMonth) || ($release[2] != $btDay))
	{
		print "WARNING: File base_time date does not match Sounding Description date\n";
	}
	elsif (($release[3] != $btHour) || ($release[4] != $btMinute) || ($release[5] != $btSecond))
	{
		printf "WARNING: File base_time time %02d:%02d:%02d does not match Sounding Description time %02d:%02d:%02d\n", $btHour,$btMinute,$btSecond,$release[3],$release[4],$release[5];
	}
	
	# ---------------------------------------------
	# print the header info to the output file
	# ---------------------------------------------
    my $siteOp = "FAAM";

    my $outfile = sprintf ("%s/%s_%s_%04d%02d%02d%02d%02d%02d.cls", $self->{"OUTPUT_DIR"},
	                       $siteOp, $self->{"NETWORK"}, $release[0], $release[1], 
						   $release[2], $release[3], $release[4], $release[5]); 
    
	open (OUTFILE,">$outfile") 
       or die "Can't open output file $outfile:$!\n";       
	print "\tOutput File Name: $outfile\n";
	
	# --------------------------------------------------
    # Use the final data record for header values
	# for latitude, longitude and altitude.  We want
	# the LAST value (since dropsonde data is reversed).  
    # --------------------------------------------------
    my $baselat = getVar("lat", $var, ($recdimLen-1));
    my $baselon = getVar("lon", $var, ($recdimLen-1));
    my $basealt = getVar("alt", $var, ($recdimLen-1));
	# print "BASELAT: $baselat BASELON $baselon BASEALT $basealt\n";
	my $header = $self->parseHeader($baselat, $baselon, $basealt);
	
	print (OUTFILE $header->toString());

    # ---------------------------------------------------------
    # Now we have all the variables for all the records, so 
	# call parse_data_rec to loop through and print the records
    # ---------------------------------------------------------
	# create some shorter test output files here
    # $self->parse_data_rec($file,10,$var);
	$self->parse_data_rec($file,$recdimLen,$var);

	# don't forget to close OUTFILE

}


#---------------------------------------------------------------------
# Get date and location from global atts in input netCDF file.
#---------------------------------------------------------------------
sub get_global_atts 
{
    my $ncid = shift;
    my $atttype;
    my %global_atts= (); 
	# HARD-CODED global attribute values from the NetCDF file
	# SoundingDescription contains date/time info same as file name 
    foreach my $attname ("SoundingDescription","MissionId") 
	{
		# to inquire about the global attribute $attname
		if (NetCDF::attinq($ncid,-1,$attname,$atttype,my $attlen) == -1) 
		{
            die "Can't inquire of attribute type of $ARGV:$!\n";
		}
		my @value; 
	    # to get the value of a vector global attribute
        if (NetCDF::attget($ncid,-1,$attname,\@value) == -1) 
		{
            die "Can't inquire of value of attribute of $ARGV:$!\n";
		}

        ###############################################
        # my global_atts are strings (chars)   
    	###############################################
		if ($attname)
		{
		    # remove the null string terminator from each string
		    # splice(@value, -1);
	        # the foreach loop shows the chars filling the array
			# foreach my $val(@value)
			# {
			#    print "my string is $val\n";
	   	    # } 
	 		my $str = pack("C*", @value);
	   		$global_atts{$attname} = $str;
	   		if (&DEBUGgetV)
	   		{print "\t$attname = $str\n";}
    	}
		# FROM COSMIC2RAOB.PL: Assume all atts have numeric values (int,short,float,double). 
    	# Char and  byte won't work this way. Need to pack chars and store byte as ptr to
		# array.
    	else 
		{  
		    $global_atts{$attname} = $value[0]; 
		}
	}   

	# print Dumper(%global_atts);

    return(%global_atts);

}


#---------------------------------------------------------------------
# Data fields of interest.
#---------------------------------------------------------------------
sub getFields {
	# HARD-CODED variable names from the NetCDF data file
    my @names = qw( base_time time_offset time pres tdry dp rh u_wind v_wind wspd wdir dz range qp qt qrh qu qv qwind lat lon alt );
    
    return(@names);
}

sub getVar {
    my $varname = shift;
    my $var = shift;
    my $index = shift;

    my $value = $$var{$varname}{values}[$index];
    if (&DEBUGoutput) {print "$varname $index $value\n";}
    return $value;
}                          

##------------------------------------------------------------------------------
# @signature void readRawFile(String file_name, String $flight)
# <p>Convert the specified file into the CLASS format.</p>
#
# @input $file_name The name of the raw data file to be converted.
# #input $flight    The flight subdirectory in which the file is located.
##------------------------------------------------------------------------------
sub readRawFile {
    my ($self,$file_name,$flight) = @_;
    
	my $file = sprintf("%s/%s/%s",$self->{"RAW_DIR"},$flight,$file_name);
   	my $ncid;
   	if (($ncid = NetCDF::open($file,0)) == -1) 
	{
           die "Cannot open file: $file\n";
   	}   
    #-----------------------------------------------------------------
    # Get information from the file name
    # faam-dropsonde_faam_20081031131508_r0_b412_proc.nc
    #-----------------------------------------------------------------    	
   	my @parts = split('_',$file_name);
	my @soundingInfo = (split('-',$parts[0]));
	my $sounding = uc(join " ", @soundingInfo);
	# print "DATA TYPE:  $sounding\n";  # FAAM DROPSONDE
	my $siteOp = uc($parts[1]);
	# print "OPERATOR: $siteOp\n";      # FAAM              
	my $dateInfo = $parts[2];
   	# if ($dateInfo =~ /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/)
   	# {
   	# 	($year,$month,$day,$hour,$minute,$second) = ($1,$2,$3,$4,$5,$6);
   	# }
	$flightNumber = uc($parts[4]);
	print "\tFLIGHT:  $flightNumber\n";  # B412

    #-------------------------------------------------
    # Open the output file in the ../output directory.
    #-------------------------------------------------
	# get the global attributes for this file
   	%global_atts = get_global_atts($ncid);
	if ($global_atts{"MissionId"} ne $flightNumber) {
		# many of the Mission Id's are "TRAIN"
		# print "WARNING: MissionId is different from FLIGHT $flightNumber\n";
	}
	# code to get date and time from Sounding Description
	my $description = $global_atts{"SoundingDescription"};
    my @descParts = (split(" ",$description));
	$sondeId = $descParts[1];
	print "\tSonde ID:  $sondeId\n";

	my $dt = $descParts[0];
	print "\tFrom Sounding Description:  $dt\n";

	if ($dt =~ /D(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/)
	{
		# @release = (year,month,day,hour,minute,second)
		@release = ($1,$2,$3,$4,$5,$6);
	}
    else
	{
		print "WARNING:  No release time available\n";
	}

    #-------------------------------------------------
    # Read all the data from the entire input netCDF file
    #-------------------------------------------------
    (my $recDimName, my $var, my $recdimsize) = readNetCDFheader($file);
    
	$self->getData($ncid,$recDimName,$var,$recdimsize,$numSounding,$file_name);
    
	#-----------------------------------------------------------------
    # All soundings come from the BAE 146 aircraft
    #-----------------------------------------------------------------
    my $station = $self->{"stations"}->getStation($self->{"NETWORK"},$self->{"NETWORK"});
    if (!defined($station)) {
        $station = $self->build_default_station($self->{"NETWORK"},$self->{"NETWORK"});
        $self->{"stations"}->addStation($station);
    }
    my $date = sprintf("%04d, %02d, %02d",$release[0],$release[1],$release[2]);  
	$station->insertDate($date, "YYYY, MM, DD");  

    #-----------------------------------------------------------------
    # Close the input file
    #-----------------------------------------------------------------
  	if (NetCDF::close($ncid) == -1) {
        die "Can't close $file\n";
    }

    # close(OUTFILE);
}

##------------------------------------------------------------------------------
# @signature Station build_default_station(String station_id, String network)
# <p>Create a default station for the Ron Brown Ship using the specified
# station_id and network.</p>
#
# @input $station_id The identifier of the station to be created.
# @input $network The network the station belongs to.
# @return The new station object with the default values for the network.
##------------------------------------------------------------------------------
sub build_default_station {
    my ($self,$station_id,$network) = @_;
    my $station = Station->new($station_id,$network);

    # HARD-CODED values
	# prints info in 48-char field in stationCD.out file
    $station->setStationName($network);
    $station->setStateCode("99");
    $station->setReportingFrequency("no set schedule");
    $station->setNetworkIdNumber(99);
    # Platform 349, Aircraft, BAE-146
    $station->setPlatformIdNumber(349);
    $station->setMobilityFlag("m");
    return $station;
}


##------------------------------------------------------------------------------
# @signature String buildLatlonFormat(String value)
# <p>Generate the decimal format for the specified value.</p>
#
# format length must be the same as the value length or
# convertLatLong will complain (see example below)
# base lat = 36.6100006103516 base lon = -97.4899978637695
# Lat format = DDDDDDDDDDDDDDDD  Lon format = -DDDDDDDDDDDDDDDD  
#
# @input $value The value of the lat/lon being formatted.
# @output $fmt The format that corresponds the the value.
##------------------------------------------------------------------------------
sub buildLatlonFormat {
    my ($self,$value) = @_;
    
    my $fmt = $value < 0 ? "-" : "";
    while (length($fmt) < length($value)) { $fmt .= "D"; }
    return $fmt;  

}

##-------------------------------------------------------------------------
# @signature String clean_for_file_name(String text)
# <p>Remove/translate characters in a String so it can be used in a file name.</p>
#
# @input $text The String to be cleaned.
# @output $text The cleaned up String.
##-------------------------------------------------------------------------
sub clean_for_file_name {
    my ($self,$text) = @_;

    # Convert spaces to underscores.
    $text =~ s/\s+/_/g;

    # Remove all hyphens
    $text =~ s/\-//g;

    return $text;
}

##------------------------------------------------------------------------------
# @signature String trim(String line)
# <p>Remove the leading and trailing whitespace around a String.</p>
#
# @input $line The String to be trimmed.
# @output $line The trimmed line.
##------------------------------------------------------------------------------
sub trim {
    my $line = shift;
    $line =~ s/^\s+//g;
    $line =~ s/\s+$//g;
    return $line;
}






